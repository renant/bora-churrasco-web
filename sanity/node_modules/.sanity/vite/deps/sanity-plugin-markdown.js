import {
  Ae,
  CheckmarkIcon,
  ChevronDownIcon,
  CloseIcon,
  Le,
  PatchEvent,
  RemoveIcon,
  SelectIcon,
  SpinnerIcon,
  ToggleArrowRightIcon,
  We,
  Xe,
  arrow,
  autoUpdate,
  computePosition,
  definePlugin,
  defineType,
  detectOverflow,
  flip,
  hide,
  offset,
  require_Refractor,
  require_react_dom,
  require_react_is,
  set$2,
  shift,
  styled_components_browser_esm_default,
  unset,
  useClient
} from "./chunk-GLKCBPWN.js";
import {
  require_jsx_runtime
} from "./chunk-W7O3NKM5.js";
import {
  require_react
} from "./chunk-Z7L3MLVS.js";
import {
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/sanity-plugin-markdown/lib/index.esm.js
import "/root/projetos/bora-churrasco-web/sanity/node_modules/easymde/dist/easymde.min.css";

// node_modules/sanity-plugin-markdown/lib/_chunks/plugin-ca10aa4c.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());

// node_modules/sanity-plugin-markdown/node_modules/@sanity/ui/dist/index.esm.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react2 = __toESM(require_react());
var import_react_is = __toESM(require_react_is());

// node_modules/sanity-plugin-markdown/node_modules/@sanity/color/dist/index.js
var black$1 = "#101112";
var white$1 = "#fff";
var gray = {
  "50": {
    title: "Gray 50",
    hex: "#f2f3f5"
  },
  "100": {
    title: "Gray 100",
    hex: "#e6e8ec"
  },
  "200": {
    title: "Gray 200",
    hex: "#ced2d9"
  },
  "300": {
    title: "Gray 300",
    hex: "#b6bcc6"
  },
  "400": {
    title: "Gray 400",
    hex: "#9ea6b3"
  },
  "500": {
    title: "Gray 500",
    hex: "#8690a0"
  },
  "600": {
    title: "Gray 600",
    hex: "#6e7683"
  },
  "700": {
    title: "Gray 700",
    hex: "#565d67"
  },
  "800": {
    title: "Gray 800",
    hex: "#3f434a"
  },
  "900": {
    title: "Gray 900",
    hex: "#272a2e"
  },
  "950": {
    title: "Gray 950",
    hex: "#1b1d20"
  }
};
var blue = {
  "50": {
    title: "Blue 50",
    hex: "#e8f1fe"
  },
  "100": {
    title: "Blue 100",
    hex: "#d2e3fe"
  },
  "200": {
    title: "Blue 200",
    hex: "#a6c8fd"
  },
  "300": {
    title: "Blue 300",
    hex: "#7aacfd"
  },
  "400": {
    title: "Blue 400",
    hex: "#4e91fc"
  },
  "500": {
    title: "Blue 500",
    hex: "#2276fc"
  },
  "600": {
    title: "Blue 600",
    hex: "#1e61cd"
  },
  "700": {
    title: "Blue 700",
    hex: "#1a4d9e"
  },
  "800": {
    title: "Blue 800",
    hex: "#17396f"
  },
  "900": {
    title: "Blue 900",
    hex: "#132540"
  },
  "950": {
    title: "Blue 950",
    hex: "#111b29"
  }
};
var purple = {
  "50": {
    title: "Purple 50",
    hex: "#f8e9fe"
  },
  "100": {
    title: "Purple 100",
    hex: "#f2d3fe"
  },
  "200": {
    title: "Purple 200",
    hex: "#e6a7fd"
  },
  "300": {
    title: "Purple 300",
    hex: "#d97bfd"
  },
  "400": {
    title: "Purple 400",
    hex: "#cd4efc"
  },
  "500": {
    title: "Purple 500",
    hex: "#c123fc"
  },
  "600": {
    title: "Purple 600",
    hex: "#9d1fcd"
  },
  "700": {
    title: "Purple 700",
    hex: "#7a1b9e"
  },
  "800": {
    title: "Purple 800",
    hex: "#56186f"
  },
  "900": {
    title: "Purple 900",
    hex: "#331440"
  },
  "950": {
    title: "Purple 950",
    hex: "#211229"
  }
};
var magenta = {
  "50": {
    title: "Magenta 50",
    hex: "#fcebf5"
  },
  "100": {
    title: "Magenta 100",
    hex: "#f9d7eb"
  },
  "200": {
    title: "Magenta 200",
    hex: "#f4afd8"
  },
  "300": {
    title: "Magenta 300",
    hex: "#ef87c4"
  },
  "400": {
    title: "Magenta 400",
    hex: "#ea5fb1"
  },
  "500": {
    title: "Magenta 500",
    hex: "#e5389e"
  },
  "600": {
    title: "Magenta 600",
    hex: "#ba3082"
  },
  "700": {
    title: "Magenta 700",
    hex: "#8f2866"
  },
  "800": {
    title: "Magenta 800",
    hex: "#65204a"
  },
  "900": {
    title: "Magenta 900",
    hex: "#3a182d"
  },
  "950": {
    title: "Magenta 950",
    hex: "#25141f"
  }
};
var red = {
  "50": {
    title: "Red 50",
    hex: "#fdebea"
  },
  "100": {
    title: "Red 100",
    hex: "#fcd8d5"
  },
  "200": {
    title: "Red 200",
    hex: "#f9b1ab"
  },
  "300": {
    title: "Red 300",
    hex: "#f68b82"
  },
  "400": {
    title: "Red 400",
    hex: "#f36458"
  },
  "500": {
    title: "Red 500",
    hex: "#f03e2f"
  },
  "600": {
    title: "Red 600",
    hex: "#c33529"
  },
  "700": {
    title: "Red 700",
    hex: "#962c23"
  },
  "800": {
    title: "Red 800",
    hex: "#69231d"
  },
  "900": {
    title: "Red 900",
    hex: "#3c1a17"
  },
  "950": {
    title: "Red 950",
    hex: "#261514"
  }
};
var orange = {
  "50": {
    title: "Orange 50",
    hex: "#fef0e6"
  },
  "100": {
    title: "Orange 100",
    hex: "#fee2ce"
  },
  "200": {
    title: "Orange 200",
    hex: "#fdc59d"
  },
  "300": {
    title: "Orange 300",
    hex: "#fca86d"
  },
  "400": {
    title: "Orange 400",
    hex: "#fb8b3c"
  },
  "500": {
    title: "Orange 500",
    hex: "#e57322"
  },
  "600": {
    title: "Orange 600",
    hex: "#ba5f1f"
  },
  "700": {
    title: "Orange 700",
    hex: "#904b1b"
  },
  "800": {
    title: "Orange 800",
    hex: "#653818"
  },
  "900": {
    title: "Orange 900",
    hex: "#3a2415"
  },
  "950": {
    title: "Orange 950",
    hex: "#251a13"
  }
};
var yellow = {
  "50": {
    title: "Yellow 50",
    hex: "#fef7da"
  },
  "100": {
    title: "Yellow 100",
    hex: "#fdefb6"
  },
  "200": {
    title: "Yellow 200",
    hex: "#fcdf6d"
  },
  "300": {
    title: "Yellow 300",
    hex: "#fbd024"
  },
  "400": {
    title: "Yellow 400",
    hex: "#d9b421"
  },
  "500": {
    title: "Yellow 500",
    hex: "#b7991e"
  },
  "600": {
    title: "Yellow 600",
    hex: "#967e1c"
  },
  "700": {
    title: "Yellow 700",
    hex: "#746219"
  },
  "800": {
    title: "Yellow 800",
    hex: "#534717"
  },
  "900": {
    title: "Yellow 900",
    hex: "#312c14"
  },
  "950": {
    title: "Yellow 950",
    hex: "#201e13"
  }
};
var green = {
  "50": {
    title: "Green 50",
    hex: "#e7f9ed"
  },
  "100": {
    title: "Green 100",
    hex: "#d0f4dc"
  },
  "200": {
    title: "Green 200",
    hex: "#a1eaba"
  },
  "300": {
    title: "Green 300",
    hex: "#72e097"
  },
  "400": {
    title: "Green 400",
    hex: "#43d675"
  },
  "500": {
    title: "Green 500",
    hex: "#3ab564"
  },
  "600": {
    title: "Green 600",
    hex: "#329454"
  },
  "700": {
    title: "Green 700",
    hex: "#297343"
  },
  "800": {
    title: "Green 800",
    hex: "#215233"
  },
  "900": {
    title: "Green 900",
    hex: "#183122"
  },
  "950": {
    title: "Green 950",
    hex: "#14211a"
  }
};
var cyan = {
  "50": {
    title: "Cyan 50",
    hex: "#e3fafd"
  },
  "100": {
    title: "Cyan 100",
    hex: "#c7f5fc"
  },
  "200": {
    title: "Cyan 200",
    hex: "#90ecf9"
  },
  "300": {
    title: "Cyan 300",
    hex: "#59e3f6"
  },
  "400": {
    title: "Cyan 400",
    hex: "#22daf4"
  },
  "500": {
    title: "Cyan 500",
    hex: "#1fb8ce"
  },
  "600": {
    title: "Cyan 600",
    hex: "#1c97a8"
  },
  "700": {
    title: "Cyan 700",
    hex: "#197583"
  },
  "800": {
    title: "Cyan 800",
    hex: "#16545d"
  },
  "900": {
    title: "Cyan 900",
    hex: "#133237"
  },
  "950": {
    title: "Cyan 950",
    hex: "#112124"
  }
};
var hues = {
  gray,
  blue,
  purple,
  magenta,
  red,
  orange,
  yellow,
  green,
  cyan
};
var black = {
  title: "Black",
  hex: black$1
};
var white = {
  title: "White",
  hex: white$1
};

// node_modules/sanity-plugin-markdown/node_modules/@sanity/ui/dist/index.esm.js
var import_react_refractor = __toESM(require_Refractor());

// node_modules/sanity-plugin-markdown/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
var React = __toESM(require_react());
var import_react = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());
var arrow2 = (options) => {
  const {
    element,
    padding
  } = options;
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(args) {
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow({
            element: element.current,
            padding
          }).fn(args);
        }
        return {};
      } else if (element) {
        return arrow({
          element,
          padding
        }).fn(args);
      }
      return {};
    }
  };
};
var index = typeof document !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length, i, keys;
  if (a && b && typeof a == "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key2 = keys[i];
      if (key2 === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key2], b[key2])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React.useState(null);
  const [_floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node) => {
    if (node != referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, [_setReference]);
  const setFloating = React.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, [_setFloating]);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      } else {
        update();
      }
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}

// node_modules/sanity-plugin-markdown/node_modules/@sanity/ui/dist/index.esm.js
var import_react_dom2 = __toESM(require_react_dom());
var EMPTY_ARRAY = [];
var EMPTY_RECORD = {};
var FLOATING_STATIC_SIDES = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
function _fillCSSObject(keys, value) {
  return keys.reduce((style, key2) => {
    style[key2] = value;
    return style;
  }, {});
}
function rem(pixelValue) {
  if (pixelValue === 0)
    return 0;
  return "".concat(pixelValue / 16, "rem");
}
function _responsive(media, values, callback) {
  const statements = (values == null ? void 0 : values.map(callback)) || [];
  return statements.map((statement, mediaIndex) => {
    if (mediaIndex === 0)
      return statement;
    return {
      ["@media screen and (min-width: ".concat(media[mediaIndex - 1], "px)")]: statement
    };
  });
}
function _getArrayProp(val, defaultVal) {
  if (val === void 0)
    return defaultVal || EMPTY_ARRAY;
  return Array.isArray(val) ? val : [val];
}
function _getResponsiveSpace(theme, props) {
  let spaceIndexes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EMPTY_ARRAY;
  if (!Array.isArray(spaceIndexes)) {
    throw new Error("the property must be array of numbers");
  }
  if (spaceIndexes.length === 0) {
    return null;
  }
  return _responsive(theme.sanity.media, spaceIndexes, (spaceIndex) => _fillCSSObject(props, rem(theme.sanity.space[spaceIndex])));
}
function responsiveFont(fontKey, props) {
  const {
    $size,
    $weight,
    theme
  } = props;
  const {
    fonts,
    media
  } = theme.sanity;
  const {
    family,
    sizes,
    weights
  } = fonts[fontKey];
  const fontWeight = $weight && weights[$weight] || weights.regular;
  const defaultSize = sizes[2];
  const base = {
    position: "relative",
    fontFamily: family,
    fontWeight,
    padding: "1px 0",
    margin: 0,
    "&:before": {
      content: '""',
      display: "block",
      height: 0
    },
    "&:after": {
      content: '""',
      display: "block",
      height: 0
    },
    "& > code, & > span": {
      display: "block"
    },
    "&:not([hidden])": {
      display: "block"
    }
  };
  if (!$size) {
    if (!responsiveFont.warned) {
      console.warn("No size specified for responsive font", {
        fontKey,
        $size,
        props,
        base
      });
      responsiveFont.warned = true;
    }
    return [base];
  }
  const resp = _responsive(media, $size, (sizeIndex) => fontSize(sizes[sizeIndex] || defaultSize));
  return [base, ...resp];
}
function fontSize(size3) {
  const {
    ascenderHeight,
    descenderHeight,
    fontSize: fontSize2,
    iconSize,
    letterSpacing,
    lineHeight
  } = size3;
  const negHeight = ascenderHeight + descenderHeight;
  const capHeight = lineHeight - negHeight;
  const iconOffset = (capHeight - iconSize) / 2;
  const customIconSize = Math.floor(fontSize2 * 1.125 / 2) * 2 + 1;
  const customIconOffset = (capHeight - customIconSize) / 2;
  return {
    fontSize: rem(fontSize2),
    lineHeight: "calc(".concat(lineHeight, " / ").concat(fontSize2, ")"),
    letterSpacing: rem(letterSpacing),
    transform: "translateY(".concat(rem(descenderHeight), ")"),
    "&:before": {
      marginTop: "calc(".concat(rem(0 - negHeight), " - 1px)")
    },
    "&:after": {
      marginBottom: "-1px"
    },
    "& svg:not([data-sanity-icon])": {
      fontSize: "calc(".concat(customIconSize, " / 16 * 1rem)"),
      margin: rem(customIconOffset)
    },
    "& [data-sanity-icon]": {
      fontSize: "calc(".concat(iconSize, " / 16 * 1rem)"),
      margin: rem(iconOffset)
    }
  };
}
function responsiveCodeFontStyle(props) {
  return responsiveFont("code", props);
}
function responsiveHeadingFont(props) {
  return responsiveFont("heading", props);
}
function responsiveLabelFont(props) {
  return responsiveFont("label", props);
}
function responsiveTextAlignStyle(props) {
  const {
    theme
  } = props;
  return _responsive(theme.sanity.media, props.$align, (textAlign) => {
    return {
      textAlign
    };
  });
}
function responsiveTextFont(props) {
  return responsiveFont("text", props);
}
function useArrayProp(val, defaultVal) {
  const __perf_hash__ = (0, import_react2.useMemo)(() => JSON.stringify(val != null ? val : defaultVal), [defaultVal, val]);
  return (0, import_react2.useMemo)(
    () => _getArrayProp(val, defaultVal),
    // Improve performance: Keep object identify for a given hash of the value
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [__perf_hash__]
  );
}
function _getElements(element, elementsArg) {
  const ret = [element];
  for (const el of elementsArg) {
    if (Array.isArray(el)) {
      ret.push(...el);
    } else {
      ret.push(el);
    }
  }
  return ret.filter(Boolean);
}
function useClickOutside(listener) {
  let elementsArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : EMPTY_ARRAY;
  let boundaryElement = arguments.length > 2 ? arguments[2] : void 0;
  const [element, setElement] = (0, import_react2.useState)(null);
  const [elements, setElements] = (0, import_react2.useState)(() => _getElements(element, elementsArg));
  const elementsRef = (0, import_react2.useRef)(elements);
  (0, import_react2.useEffect)(() => {
    const prevElements = elementsRef.current;
    const nextElements = _getElements(element, elementsArg);
    if (prevElements.length !== nextElements.length) {
      setElements(nextElements);
      elementsRef.current = nextElements;
      return;
    }
    for (const el of prevElements) {
      if (!nextElements.includes(el)) {
        setElements(nextElements);
        elementsRef.current = nextElements;
        return;
      }
    }
    for (const el of nextElements) {
      if (!prevElements.includes(el)) {
        setElements(nextElements);
        elementsRef.current = nextElements;
        return;
      }
    }
  }, [element, elementsArg]);
  (0, import_react2.useEffect)(() => {
    if (!listener)
      return void 0;
    const handleWindowMouseDown = (evt) => {
      const target = evt.target;
      if (!(target instanceof Node)) {
        return;
      }
      if (boundaryElement && !boundaryElement.contains(target)) {
        return;
      }
      for (const el of elements) {
        if (target === el || el.contains(target)) {
          return;
        }
      }
      listener(evt);
    };
    window.addEventListener("mousedown", handleWindowMouseDown);
    return () => {
      window.removeEventListener("mousedown", handleWindowMouseDown);
    };
  }, [boundaryElement, listener, elements]);
  return setElement;
}
var resizeObservers = [];
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
var freeze = function(obj) {
  return Object.freeze(obj);
};
var ResizeObserverSize = function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize2;
}();
var DOMRectReadOnly = function() {
  function DOMRectReadOnly2(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a2 = this, x = _a2.x, y = _a2.y, top = _a2.top, right = _a2.right, bottom = _a2.bottom, left = _a2.left, width = _a2.width, height = _a2.height;
    return {
      x,
      y,
      top,
      right,
      bottom,
      left,
      width,
      height
    };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
}();
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a2 = target.getBBox(), width = _a2.width, height = _a2.height;
    return !width && !height;
  }
  var _b2 = target, offsetWidth = _b2.offsetWidth, offsetHeight = _b2.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function(obj) {
  var _a2;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a2 = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};
var global$1 = typeof window !== "undefined" ? window : {};
var cache = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size$1 = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size$1(),
  borderBoxSize: size$1(),
  contentBoxSize: size$1(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if (isHidden(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop2 = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight2 = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom2 = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft2 = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft2 + borderRight2;
  var verticalBorderArea = borderTop2 + borderBottom2;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size$1(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size$1(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size$1(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a2 = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a2.borderBoxSize, contentBoxSize = _a2.contentBoxSize, devicePixelContentBoxSize = _a2.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
}();
var calculateDepthForNode = function(node) {
  if (isHidden(node)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};
var process = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};
var trigger;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
};
var queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config = {
      characterData: true
    };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config);
    trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};
var queueResizeObserver = function(cb) {
  queueMicroTask(function ResizeObserver2() {
    requestAnimationFrame(cb);
  });
};
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = {
  attributes: true,
  characterData: true,
  childList: true,
  subtree: true
};
var events = ["resize", "load", "transitionend", "animationend", "animationstart", "animationiteration", "keyup", "keydown", "mouseup", "mousedown", "mouseover", "mouseout", "blur", "focus"];
var time = function(timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function() {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process();
      } finally {
        scheduled = false;
        timeout = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this = this;
    var cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global$1.addEventListener("DOMContentLoaded", cb);
  };
  Scheduler2.prototype.start = function() {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name) {
        return global$1.addEventListener(name, _this.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name) {
        return global$1.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
}();
var scheduler = new Scheduler();
var updateCount = function(n) {
  !watching && n > 0 && scheduler.start();
  watching += n;
  !watching && scheduler.stop();
};
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size3 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size3;
    }
    if (this.lastReportedSize.inlineSize !== size3.inlineSize || this.lastReportedSize.blockSize !== size3.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
}();
var ResizeObserverDetail = function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
}();
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i = 0; i < observationTargets.length; i += 1) {
    if (observationTargets[i].target === target) {
      return i;
    }
  }
  return -1;
};
var ResizeObserverController = function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index2 = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index2 >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index2, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
}();
var ResizeObserver = function() {
  function ResizeObserver2(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver2.prototype.observe = function(target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver2.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver2.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver2.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver2;
}();
var _ResizeObserver = typeof document !== "undefined" && typeof window !== "undefined" && window.ResizeObserver ? window.ResizeObserver : ResizeObserver;
var _elementSizeObserver = _createElementSizeObserver();
function _createElementRectValueListener() {
  return {
    subscribe(element, subscriber) {
      const resizeObserver = new _ResizeObserver((_ref) => {
        let [entry] = _ref;
        subscriber({
          _contentRect: entry.contentRect,
          border: {
            width: entry.borderBoxSize[0].inlineSize,
            height: entry.borderBoxSize[0].blockSize
          },
          content: {
            width: entry.contentRect.width,
            height: entry.contentRect.height
          }
        });
      });
      resizeObserver.observe(element);
      return () => {
        resizeObserver.unobserve(element);
        resizeObserver.disconnect();
      };
    }
  };
}
function _createElementSizeObserver() {
  const disposeCache = /* @__PURE__ */ new WeakMap();
  const subscribersCache = /* @__PURE__ */ new WeakMap();
  return {
    subscribe(element, subscriber) {
      const subscribers = subscribersCache.get(element) || [];
      let dispose = disposeCache.get(element);
      if (!subscribersCache.has(element)) {
        subscribersCache.set(element, subscribers);
        const listener = _createElementRectValueListener();
        dispose = listener.subscribe(element, (elementRect) => {
          for (const sub of subscribers) {
            sub(elementRect);
          }
        });
      }
      subscribers.push(subscriber);
      return () => {
        const idx = subscribers.indexOf(subscriber);
        if (idx > -1) {
          subscribers.splice(idx, 1);
        }
        if (subscribers.length === 0) {
          if (dispose)
            dispose();
        }
      };
    }
  };
}
function useElementSize(element) {
  const [size3, setSize] = (0, import_react2.useState)(null);
  (0, import_react2.useEffect)(() => {
    if (!element)
      return void 0;
    return _elementSizeObserver.subscribe(element, setSize);
  }, [element]);
  return size3;
}
function useGlobalKeyDown(onKeyDown) {
  return (0, import_react2.useEffect)(() => {
    addEventListener("keydown", onKeyDown);
    return () => removeEventListener("keydown", onKeyDown);
  }, [onKeyDown]);
}
function multiplyChannel(b, s) {
  return b * s;
}
function multiply$1(b, s) {
  return {
    r: Math.round(clamp$1(multiplyChannel(b.r / 255, s.r / 255) * 255)),
    g: Math.round(clamp$1(multiplyChannel(b.g / 255, s.g / 255) * 255)),
    b: Math.round(clamp$1(multiplyChannel(b.b / 255, s.b / 255) * 255))
  };
}
function clamp$1(num) {
  return Math.max(Math.min(num, 255), 0);
}
function screenChannel(b, s) {
  return b + s - b * s;
}
function screen$1(b, s) {
  return {
    r: Math.round(clamp(screenChannel(b.r / 255, s.r / 255) * 255)),
    g: Math.round(clamp(screenChannel(b.g / 255, s.g / 255) * 255)),
    b: Math.round(clamp(screenChannel(b.b / 255, s.b / 255) * 255))
  };
}
function clamp(num) {
  return Math.max(Math.min(num, 255), 0);
}
function hexToRgb(hex) {
  if (hex.length === 4) {
    const hexR = hex.slice(1, 2);
    const hexG = hex.slice(2, 3);
    const hexB = hex.slice(3, 4);
    return {
      r: parseInt(hexR + hexR, 16),
      g: parseInt(hexG + hexG, 16),
      b: parseInt(hexB + hexB, 16)
    };
  }
  return {
    r: parseInt(hex.slice(1, 3), 16),
    g: parseInt(hex.slice(3, 5), 16),
    b: parseInt(hex.slice(5, 7), 16)
  };
}
function rgbToHex(_ref2) {
  let {
    r,
    g,
    b
  } = _ref2;
  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}
function hslToRgb(hsl) {
  const s = hsl.s / 100;
  const l = hsl.l / 100;
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs(hsl.h / 60 % 2 - 1));
  const m = l - c / 2;
  let r = 0;
  let g = 0;
  let b = 0;
  if (0 <= hsl.h && hsl.h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (60 <= hsl.h && hsl.h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (120 <= hsl.h && hsl.h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (180 <= hsl.h && hsl.h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (240 <= hsl.h && hsl.h < 300) {
    r = x;
    g = 0;
    b = c;
  } else if (300 <= hsl.h && hsl.h < 360) {
    r = c;
    g = 0;
    b = x;
  }
  return {
    r: Math.round((r + m) * 255),
    g: Math.round((g + m) * 255),
    b: Math.round((b + m) * 255)
  };
}
var HEX_CHARS = "0123456789ABCDEFabcdef";
var HSL_RE = /hsl\(\s*(\d+)\s*,\s*((\d+(?:\.\d+)?)%)\s*,\s*((\d+(?:\.\d+)?)%)\s*\)/i;
function isHexChars(str) {
  for (const c of str) {
    if (HEX_CHARS.indexOf(c) === -1) {
      return false;
    }
  }
  return true;
}
function isHex(str) {
  if (str[0] !== "#")
    return false;
  if (!(str.length === 4 || str.length === 7))
    return false;
  return isHexChars(str.slice(1));
}
function parseHsl(str) {
  const res = HSL_RE.exec(str);
  if (!res) {
    throw new Error('parseHsl: string is not a HSL color: "'.concat(str, '"'));
  }
  return {
    h: parseInt(res[1]),
    s: parseFloat(res[3]),
    l: parseFloat(res[5])
  };
}
function parseColor(color2) {
  if (!color2)
    return {
      r: 0,
      g: 0,
      b: 0
    };
  if (typeof color2 !== "string") {
    throw new Error("parseColor: expected a string");
  }
  if (isHex(color2)) {
    return hexToRgb(color2);
  }
  if (color2.startsWith("hsl(")) {
    return hslToRgb(parseHsl(color2));
  }
  throw new Error('parseColor: unexpected color format: "'.concat(color2, '"'));
}
function rgba(color2, a) {
  const rgb = parseColor(color2);
  return "rgba(".concat(rgb.r, ",").concat(rgb.g, ",").concat(rgb.b, ",").concat(a, ")");
}
function createButtonTones(opts, base, dark, solid, muted, mode) {
  return {
    default: opts.button({
      base,
      dark,
      solid: solid.default,
      muted: muted.default,
      mode
    }),
    primary: opts.button({
      base,
      dark,
      solid: solid.primary,
      muted: muted.primary,
      mode
    }),
    positive: opts.button({
      base,
      dark,
      solid: solid.positive,
      muted: muted.positive,
      mode
    }),
    caution: opts.button({
      base,
      dark,
      solid: solid.caution,
      muted: muted.caution,
      mode
    }),
    critical: opts.button({
      base,
      dark,
      solid: solid.critical,
      muted: muted.critical,
      mode
    })
  };
}
function createButtonModes(opts, base, dark, solid, muted) {
  return {
    default: createButtonTones(opts, base, dark, solid, muted, "default"),
    ghost: createButtonTones(opts, base, dark, solid, muted, "ghost"),
    bleed: createButtonTones(opts, base, dark, solid, muted, "bleed")
  };
}
function createCardStates(opts, base, dark, name, solid, muted) {
  return {
    enabled: opts.card({
      base,
      dark,
      name,
      state: "enabled",
      solid,
      muted
    }),
    disabled: opts.card({
      base,
      dark,
      name,
      state: "disabled",
      solid,
      muted
    }),
    hovered: opts.card({
      base,
      dark,
      name,
      state: "hovered",
      solid,
      muted
    }),
    pressed: opts.card({
      base,
      dark,
      name,
      state: "pressed",
      solid,
      muted
    }),
    selected: opts.card({
      base,
      dark,
      name,
      state: "selected",
      solid,
      muted
    })
  };
}
var black2 = "hsl(0, 0%, 0%)";
var white2 = "hsl(0, 0%, 100%)";
var colors = {
  default: {
    lightest: "hsl(0, 0%, 95%)",
    lighter: "hsl(0, 0%, 70%)",
    light: "hsl(0, 0%, 65%)",
    base: "hsl(0, 0%, 50%)",
    dark: "hsl(0, 0%, 35%)",
    darker: "hsl(0, 0%, 20%)",
    darkest: "hsl(0, 0%, 5%)"
  },
  transparent: {
    lightest: "hsl(240, 100%, 95%)",
    lighter: "hsl(240, 100%, 70%)",
    light: "hsl(240, 100%, 65%)",
    base: "hsl(240, 100%, 50%)",
    dark: "hsl(240, 100%, 35%)",
    darker: "hsl(240, 100%, 20%)",
    darkest: "hsl(240, 100%, 5%)"
  },
  primary: {
    lightest: "hsl(240, 100%, 95%)",
    lighter: "hsl(240, 100%, 70%)",
    light: "hsl(240, 100%, 65%)",
    base: "hsl(240, 100%, 50%)",
    dark: "hsl(240, 100%, 35%)",
    darker: "hsl(240, 100%, 20%)",
    darkest: "hsl(240, 100%, 5%)"
  },
  positive: {
    lightest: "hsl(120, 100%, 95%)",
    lighter: "hsl(120, 100%, 70%)",
    light: "hsl(120, 100%, 65%)",
    base: "hsl(120, 100%, 50%)",
    dark: "hsl(120, 100%, 35%)",
    darker: "hsl(120, 100%, 20%)",
    darkest: "hsl(120, 100%, 5%)"
  },
  caution: {
    lightest: "hsl(60, 100%, 95%)",
    lighter: "hsl(60, 100%, 70%)",
    light: "hsl(60, 100%, 65%)",
    base: "hsl(60, 100%, 50%)",
    dark: "hsl(60, 100%, 35%)",
    darker: "hsl(60, 100%, 20%)",
    darkest: "hsl(60, 100%, 5%)"
  },
  critical: {
    lightest: "hsl(0, 100%, 95%)",
    lighter: "hsl(0, 100%, 70%)",
    light: "hsl(0, 100%, 65%)",
    base: "hsl(0, 100%, 50%)",
    dark: "hsl(0, 100%, 35%)",
    darker: "hsl(0, 100%, 20%)",
    darkest: "hsl(0, 100%, 5%)"
  }
};
var spots = {
  gray: "hsl(0, 0%, 50%)",
  red: "hsl(0, 100%, 50%)",
  orange: "hsl(30, 100%, 50%)",
  yellow: "hsl(60, 100%, 50%)",
  green: "hsl(120, 100%, 50%)",
  cyan: "hsl(180, 100%, 50%)",
  blue: "hsl(240, 100%, 50%)",
  purple: "hsl(270, 100%, 50%)",
  magenta: "hsl(300, 100%, 50%)"
};
var tones$1 = {
  transparent: {
    bg: [colors.transparent.darkest, colors.transparent.lightest],
    fg: [colors.transparent.lightest, colors.transparent.darkest],
    border: [colors.transparent.darker, colors.transparent.lighter],
    focusRing: [colors.transparent.base, colors.transparent.base]
  },
  primary: {
    bg: [colors.primary.darkest, colors.primary.lightest],
    fg: [colors.primary.lightest, colors.primary.darkest],
    border: [colors.primary.darker, colors.primary.lighter],
    focusRing: [colors.primary.base, colors.primary.base]
  },
  positive: {
    bg: [colors.positive.darkest, colors.positive.lightest],
    fg: [colors.positive.lightest, colors.positive.darkest],
    border: [colors.positive.darker, colors.positive.lighter],
    focusRing: [colors.positive.base, colors.positive.base]
  },
  caution: {
    bg: [colors.caution.darkest, colors.caution.lightest],
    fg: [colors.caution.lightest, colors.caution.darkest],
    border: [colors.caution.darker, colors.caution.lighter],
    focusRing: [colors.caution.base, colors.caution.base]
  },
  critical: {
    bg: [colors.critical.darkest, colors.critical.lightest],
    fg: [colors.critical.lightest, colors.critical.darkest],
    border: [colors.critical.darker, colors.critical.lighter],
    focusRing: [colors.critical.base, colors.critical.base]
  }
};
var defaultOpts = {
  base: (_ref4) => {
    let {
      dark,
      name
    } = _ref4;
    if (name === "default") {
      return {
        bg: dark ? black2 : white2,
        fg: dark ? white2 : black2,
        border: dark ? colors.default.darkest : colors.default.lightest,
        focusRing: colors.primary.base,
        shadow: {
          outline: black2,
          umbra: black2,
          penumbra: black2,
          ambient: black2
        },
        skeleton: {
          from: dark ? white2 : black2,
          to: dark ? white2 : black2
        }
      };
    }
    return {
      bg: tones$1[name].bg[dark ? 0 : 1],
      fg: tones$1[name].fg[dark ? 0 : 1],
      border: tones$1[name].border[dark ? 0 : 1],
      focusRing: tones$1[name].focusRing[dark ? 0 : 1],
      shadow: {
        outline: black2,
        umbra: black2,
        penumbra: black2,
        ambient: black2
      },
      skeleton: {
        from: dark ? white2 : black2,
        to: dark ? white2 : black2
      }
    };
  },
  solid: (_ref5) => {
    let {
      base,
      dark,
      state,
      tone
    } = _ref5;
    const color2 = colors[tone];
    if (state === "hovered") {
      return {
        bg: dark ? color2.light : color2.dark,
        bg2: dark ? color2.light : color2.dark,
        border: dark ? color2.lighter : color2.darker,
        fg: dark ? color2.darkest : color2.lightest,
        muted: {
          fg: black2
        },
        accent: {
          fg: black2
        },
        link: {
          fg: black2
        },
        code: {
          bg: black2,
          fg: black2
        },
        skeleton: base.skeleton
      };
    }
    return {
      bg: color2.base,
      bg2: color2.base,
      border: dark ? color2.light : color2.dark,
      fg: dark ? color2.darkest : color2.lightest,
      muted: {
        fg: black2
      },
      accent: {
        fg: black2
      },
      link: {
        fg: black2
      },
      code: {
        bg: black2,
        fg: black2
      },
      skeleton: base.skeleton
    };
  },
  muted: (_ref6) => {
    let {
      base,
      dark,
      state,
      tone
    } = _ref6;
    const color2 = colors[tone];
    if (state === "hovered") {
      return {
        bg: dark ? color2.darker : color2.lighter,
        bg2: dark ? color2.darker : color2.lighter,
        border: dark ? color2.lighter : color2.darker,
        fg: dark ? color2.lightest : color2.darkest,
        muted: {
          fg: black2
        },
        accent: {
          fg: black2
        },
        link: {
          fg: black2
        },
        code: {
          bg: black2,
          fg: black2
        },
        skeleton: base.skeleton
      };
    }
    return {
      bg: dark ? color2.darkest : color2.lightest,
      bg2: dark ? color2.darkest : color2.lightest,
      border: dark ? color2.darker : color2.lighter,
      fg: dark ? color2.lighter : color2.darker,
      muted: {
        fg: black2
      },
      accent: {
        fg: black2
      },
      link: {
        fg: black2
      },
      code: {
        bg: black2,
        fg: black2
      },
      skeleton: base.skeleton
    };
  },
  button: (_ref7) => {
    let {
      base,
      mode,
      muted,
      solid
    } = _ref7;
    if (mode === "bleed") {
      return {
        ...muted,
        enabled: {
          bg: "transparent",
          bg2: "transparent",
          fg: muted.enabled.fg,
          border: "transparent",
          muted: {
            fg: black2
          },
          accent: {
            fg: black2
          },
          link: {
            fg: black2
          },
          code: {
            bg: black2,
            fg: black2
          },
          skeleton: base.skeleton
        },
        hovered: {
          bg: muted.enabled.bg,
          bg2: muted.enabled.bg,
          fg: muted.hovered.fg,
          border: "transparent",
          muted: {
            fg: black2
          },
          accent: {
            fg: black2
          },
          link: {
            fg: black2
          },
          code: {
            bg: black2,
            fg: black2
          },
          skeleton: base.skeleton
        }
      };
    }
    if (mode === "ghost")
      return {
        ...solid,
        enabled: muted.enabled
      };
    return solid;
  },
  card: (_ref8) => {
    let {
      base
    } = _ref8;
    return {
      bg: black2,
      bg2: black2,
      fg: black2,
      border: black2,
      muted: {
        fg: black2
      },
      accent: {
        fg: black2
      },
      link: {
        fg: black2
      },
      code: {
        bg: black2,
        fg: black2
      },
      skeleton: base.skeleton
    };
  },
  input: () => {
    return {
      bg: black2,
      fg: black2,
      border: black2,
      placeholder: black2
    };
  },
  selectable: (_ref9) => {
    let {
      muted,
      state,
      tone
    } = _ref9;
    return muted[tone][state];
  },
  spot: (_ref10) => {
    let {
      key: key2
    } = _ref10;
    return spots[key2];
  },
  syntax: () => ({
    atrule: black2,
    attrName: black2,
    attrValue: black2,
    attribute: black2,
    boolean: black2,
    builtin: black2,
    cdata: black2,
    char: black2,
    class: black2,
    className: black2,
    comment: black2,
    constant: black2,
    deleted: black2,
    doctype: black2,
    entity: black2,
    function: black2,
    hexcode: black2,
    id: black2,
    important: black2,
    inserted: black2,
    keyword: black2,
    number: black2,
    operator: black2,
    prolog: black2,
    property: black2,
    pseudoClass: black2,
    pseudoElement: black2,
    punctuation: black2,
    regex: black2,
    selector: black2,
    string: black2,
    symbol: black2,
    tag: black2,
    unit: black2,
    url: black2,
    variable: black2
  })
};
function createInputModes(opts, base, dark, solid, muted) {
  return {
    default: {
      enabled: opts.input({
        base,
        dark,
        mode: "default",
        state: "enabled",
        solid: solid.default,
        muted: muted.default
      }),
      disabled: opts.input({
        base,
        dark,
        mode: "default",
        state: "disabled",
        solid: solid.default,
        muted: muted.default
      }),
      hovered: opts.input({
        base,
        dark,
        mode: "default",
        state: "hovered",
        solid: solid.default,
        muted: muted.default
      }),
      readOnly: opts.input({
        base,
        dark,
        mode: "default",
        state: "readOnly",
        solid: solid.default,
        muted: muted.default
      })
    },
    invalid: {
      enabled: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "enabled",
        solid: solid.default,
        muted: muted.default
      }),
      disabled: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "disabled",
        solid: solid.default,
        muted: muted.default
      }),
      hovered: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "hovered",
        solid: solid.default,
        muted: muted.default
      }),
      readOnly: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "readOnly",
        solid: solid.default,
        muted: muted.default
      })
    }
  };
}
function createMutedTones(opts, base, dark, name) {
  return {
    default: {
      enabled: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "selected"
      })
    },
    transparent: {
      enabled: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "selected"
      })
    },
    primary: {
      enabled: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "selected"
      })
    },
    positive: {
      enabled: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "selected"
      })
    },
    caution: {
      enabled: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "selected"
      })
    },
    critical: {
      enabled: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "selected"
      })
    }
  };
}
function createSelectableTones(opts, base, dark, solid, muted) {
  return {
    default: _createSelectableStates(opts, base, dark, solid, muted, "default"),
    primary: _createSelectableStates(opts, base, dark, solid, muted, "primary"),
    positive: _createSelectableStates(opts, base, dark, solid, muted, "positive"),
    caution: _createSelectableStates(opts, base, dark, solid, muted, "caution"),
    critical: _createSelectableStates(opts, base, dark, solid, muted, "critical")
  };
}
function _createSelectableStates(opts, base, dark, solid, muted, tone) {
  return {
    enabled: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "enabled",
      tone
    }),
    hovered: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "hovered",
      tone
    }),
    pressed: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "pressed",
      tone
    }),
    selected: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "selected",
      tone
    }),
    disabled: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "disabled",
      tone
    })
  };
}
function createSolidTones(opts, base, dark, name) {
  return {
    default: {
      enabled: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "selected"
      })
    },
    transparent: {
      enabled: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "selected"
      })
    },
    primary: {
      enabled: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "selected"
      })
    },
    positive: {
      enabled: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "selected"
      })
    },
    caution: {
      enabled: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "selected"
      })
    },
    critical: {
      enabled: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "selected"
      })
    }
  };
}
function createSpot(opts, base, dark) {
  return {
    gray: opts.spot({
      base,
      dark,
      key: "gray"
    }),
    blue: opts.spot({
      base,
      dark,
      key: "blue"
    }),
    purple: opts.spot({
      base,
      dark,
      key: "purple"
    }),
    magenta: opts.spot({
      base,
      dark,
      key: "magenta"
    }),
    red: opts.spot({
      base,
      dark,
      key: "red"
    }),
    orange: opts.spot({
      base,
      dark,
      key: "orange"
    }),
    yellow: opts.spot({
      base,
      dark,
      key: "yellow"
    }),
    green: opts.spot({
      base,
      dark,
      key: "green"
    }),
    cyan: opts.spot({
      base,
      dark,
      key: "cyan"
    })
  };
}
function createColorTheme() {
  let partialOpts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const builders = {
    ...defaultOpts,
    ...partialOpts
  };
  return {
    light: _createColorScheme(builders, false),
    dark: _createColorScheme(builders, true)
  };
}
function _createColorScheme(opts, dark) {
  return {
    default: _createColor(opts, dark, "default"),
    transparent: _createColor(opts, dark, "transparent"),
    primary: _createColor(opts, dark, "primary"),
    positive: _createColor(opts, dark, "positive"),
    caution: _createColor(opts, dark, "caution"),
    critical: _createColor(opts, dark, "critical")
  };
}
function _createColor(opts, dark, name) {
  const base = opts.base({
    dark,
    name
  });
  const solid = createSolidTones(opts, base, dark, name);
  const muted = createMutedTones(opts, base, dark, name);
  return {
    base,
    button: createButtonModes(opts, base, dark, solid, muted),
    card: createCardStates(opts, base, dark, name, solid, muted),
    dark,
    input: createInputModes(opts, base, dark, solid, muted),
    selectable: createSelectableTones(opts, base, dark, solid, muted),
    spot: createSpot(opts, base, dark),
    syntax: opts.syntax({
      base,
      dark
    }),
    solid,
    muted
  };
}
function multiply(bg, fg) {
  const b = parseColor(bg);
  const s = parseColor(fg);
  const hex = rgbToHex(multiply$1(b, s));
  return hex;
}
function screen(bg, fg) {
  const b = parseColor(bg);
  const s = parseColor(fg);
  const hex = rgbToHex(screen$1(b, s));
  return hex;
}
var tones = {
  default: hues.gray,
  transparent: hues.gray,
  primary: hues.blue,
  positive: hues.green,
  caution: hues.yellow,
  critical: hues.red
};
var NEUTRAL_TONES = ["default", "transparent"];
var color = createColorTheme({
  base: (_ref11) => {
    let {
      dark,
      name
    } = _ref11;
    if (name === "default") {
      const tints2 = hues.gray;
      const skeletonFrom2 = dark ? tints2[900].hex : tints2[100].hex;
      return {
        fg: dark ? white.hex : black.hex,
        bg: dark ? black.hex : white.hex,
        border: tints2[dark ? 800 : 200].hex,
        focusRing: hues.blue[dark ? 500 : 500].hex,
        shadow: {
          outline: rgba(tints2[500].hex, 0.4),
          umbra: dark ? rgba(tints2[950].hex, 0.4) : rgba(tints2[500].hex, 0.2),
          penumbra: dark ? rgba(tints2[950].hex, 0.28) : rgba(tints2[500].hex, 0.14),
          ambient: dark ? rgba(tints2[950].hex, 0.24) : rgba(tints2[500].hex, 0.12)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (name === "transparent") {
      const tints2 = tones.default;
      const skeletonFrom2 = tints2[dark ? 800 : 200].hex;
      return {
        fg: tints2[dark ? 100 : 900].hex,
        bg: tints2[dark ? 950 : 50].hex,
        border: tints2[dark ? 800 : 300].hex,
        focusRing: hues.blue[500].hex,
        shadow: {
          outline: rgba(tints2[500].hex, 0.4),
          umbra: dark ? rgba(tints2[900].hex, 0.4) : rgba(tints2[500].hex, 0.2),
          penumbra: dark ? rgba(tints2[900].hex, 0.28) : rgba(tints2[500].hex, 0.14),
          ambient: dark ? rgba(tints2[900].hex, 0.24) : rgba(tints2[500].hex, 0.12)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    const tints = tones[name] || tones.default;
    const skeletonFrom = tints[dark ? 800 : 200].hex;
    return {
      fg: tints[dark ? 100 : 900].hex,
      bg: tints[dark ? 950 : 50].hex,
      border: tints[dark ? 800 : 200].hex,
      focusRing: tints[500].hex,
      shadow: {
        outline: rgba(tints[500].hex, 0.4),
        umbra: dark ? rgba(tints[900].hex, 0.4) : rgba(tints[500].hex, 0.2),
        penumbra: dark ? rgba(tints[900].hex, 0.28) : rgba(tints[500].hex, 0.14),
        ambient: dark ? rgba(tints[900].hex, 0.24) : rgba(tints[500].hex, 0.12)
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba(skeletonFrom, 0.5)
      }
    };
  },
  solid: (_ref12) => {
    let {
      base,
      dark,
      name,
      state,
      tone
    } = _ref12;
    const mix = dark ? screen : multiply;
    const mix2 = dark ? multiply : screen;
    const defaultTints = tones[name] || tones.default;
    const isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
    let tints = tones[tone === "default" ? name : tone] || defaultTints;
    if (state === "disabled") {
      tints = defaultTints;
      const bg2 = mix(base.bg, tints[dark ? 800 : 200].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: bg2,
        bg2: mix2(bg2, tints[dark ? 50 : 950].hex),
        border: mix(base.bg, tints[dark ? 800 : 200].hex),
        fg: mix(base.bg, dark ? black.hex : white.hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 950 : 50].hex)
        },
        accent: {
          fg: mix(base.bg, tints[dark ? 950 : 50].hex)
        },
        link: {
          fg: mix(base.bg, tints[dark ? 950 : 50].hex)
        },
        code: {
          bg: bg2,
          fg: mix(base.bg, tints[dark ? 950 : 50].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "hovered") {
      const bg2 = mix(base.bg, tints[dark ? 300 : 600].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: bg2,
        bg2: mix2(bg2, tints[dark ? 50 : 950].hex),
        border: mix(base.bg, tints[dark ? 300 : 600].hex),
        fg: mix(base.bg, dark ? black.hex : white.hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        accent: {
          fg: mix2(bg2, hues.red[dark ? 800 : 200].hex)
        },
        link: {
          fg: mix2(bg2, hues.blue[dark ? 800 : 200].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "pressed") {
      const bg2 = mix(base.bg, tints[dark ? 200 : 800].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: mix(base.bg, tints[dark ? 200 : 800].hex),
        bg2: mix2(bg2, tints[dark ? 50 : 950].hex),
        border: mix(base.bg, tints[dark ? 200 : 800].hex),
        fg: mix(base.bg, dark ? black.hex : white.hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        accent: {
          fg: mix2(bg2, hues.red[dark ? 800 : 200].hex)
        },
        link: {
          fg: mix2(bg2, hues.blue[dark ? 800 : 200].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "selected") {
      if (isNeutral) {
        tints = tones.primary;
      }
      const bg2 = mix(base.bg, tints[dark ? 200 : 800].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: bg2,
        bg2: mix2(bg2, tints[dark ? 50 : 950].hex),
        border: mix(base.bg, tints[dark ? 200 : 800].hex),
        fg: mix(base.bg, dark ? black.hex : white.hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        accent: {
          fg: mix2(bg2, hues.red[dark ? 800 : 200].hex)
        },
        link: {
          fg: mix2(bg2, hues.blue[dark ? 800 : 200].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    const bg = mix(base.bg, tints[dark ? 400 : 500].hex);
    const skeletonFrom = mix2(bg, tints[dark ? 200 : 800].hex);
    return {
      bg,
      bg2: mix2(bg, tints[dark ? 50 : 950].hex),
      border: mix(base.bg, tints[dark ? 400 : 500].hex),
      fg: mix(base.bg, dark ? black.hex : white.hex),
      muted: {
        fg: mix(base.bg, tints[dark ? 900 : 100].hex)
      },
      accent: {
        fg: mix2(bg, hues.red[dark ? 900 : 100].hex)
      },
      link: {
        fg: mix2(bg, hues.blue[dark ? 900 : 100].hex)
      },
      code: {
        bg: mix(bg, tints[dark ? 950 : 50].hex),
        fg: mix(base.bg, tints[dark ? 900 : 100].hex)
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba(skeletonFrom, 0.5)
      }
    };
  },
  muted: (_ref13) => {
    let {
      base,
      dark,
      name,
      state,
      tone
    } = _ref13;
    const mix = dark ? screen : multiply;
    const defaultTints = tones[name] || tones.default;
    const isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
    let tints = tones[tone === "default" ? name : tone] || defaultTints;
    if (state === "disabled") {
      tints = defaultTints;
      const bg2 = base.bg;
      const skeletonFrom2 = mix(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix(bg2, tints[dark ? 950 : 50].hex),
        border: mix(bg2, tints[dark ? 950 : 50].hex),
        fg: mix(bg2, tints[dark ? 800 : 200].hex),
        muted: {
          fg: mix(bg2, tints[dark ? 900 : 100].hex)
        },
        accent: {
          fg: mix(bg2, tints[dark ? 900 : 100].hex)
        },
        link: {
          fg: mix(bg2, tints[dark ? 900 : 100].hex)
        },
        code: {
          bg: bg2,
          fg: mix(bg2, tints[dark ? 900 : 100].hex)
        },
        skeleton: {
          from: rgba(skeletonFrom2, 0.5),
          to: rgba(skeletonFrom2, 0.25)
        }
      };
    }
    if (state === "hovered") {
      const bg2 = mix(base.bg, tints[dark ? 950 : 50].hex);
      const skeletonFrom2 = mix(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix(bg2, tints[dark ? 950 : 50].hex),
        border: mix(bg2, tints[dark ? 900 : 100].hex),
        fg: mix(base.bg, tints[dark ? 200 : 800].hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        accent: {
          fg: mix(base.bg, hues.red[dark ? 400 : 500].hex)
        },
        link: {
          fg: mix(base.bg, hues.blue[dark ? 400 : 600].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "pressed") {
      if (isNeutral) {
        tints = tones.primary;
      }
      const bg2 = mix(base.bg, tints[dark ? 900 : 100].hex);
      const skeletonFrom2 = mix(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix(bg2, tints[dark ? 950 : 50].hex),
        border: mix(bg2, tints[dark ? 900 : 100].hex),
        fg: mix(base.bg, tints[dark ? 200 : 800].hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        accent: {
          fg: mix(bg2, hues.red[dark ? 400 : 500].hex)
        },
        link: {
          fg: mix(bg2, hues.blue[dark ? 400 : 600].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "selected") {
      if (isNeutral) {
        tints = tones.primary;
      }
      const bg2 = mix(base.bg, tints[dark ? 900 : 100].hex);
      const skeletonFrom2 = mix(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix(bg2, tints[dark ? 950 : 50].hex),
        border: mix(bg2, tints[dark ? 900 : 100].hex),
        fg: mix(base.bg, tints[dark ? 200 : 800].hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        accent: {
          fg: mix(bg2, hues.red[dark ? 400 : 500].hex)
        },
        link: {
          fg: mix(bg2, hues.blue[dark ? 400 : 600].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    const bg = base.bg;
    const skeletonFrom = mix(bg, tints[dark ? 900 : 100].hex);
    return {
      bg,
      bg2: mix(bg, tints[dark ? 950 : 50].hex),
      border: mix(bg, tints[dark ? 900 : 100].hex),
      fg: mix(base.bg, tints[dark ? 300 : 700].hex),
      muted: {
        fg: mix(base.bg, tints[dark ? 400 : 600].hex)
      },
      accent: {
        fg: mix(base.bg, hues.red[dark ? 400 : 500].hex)
      },
      link: {
        fg: mix(base.bg, hues.blue[dark ? 400 : 600].hex)
      },
      code: {
        bg: mix(base.bg, tints[dark ? 950 : 50].hex),
        fg: mix(base.bg, tints[dark ? 400 : 600].hex)
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba(skeletonFrom, 0.5)
      }
    };
  },
  button: (_ref14) => {
    let {
      base,
      mode,
      muted,
      solid
    } = _ref14;
    if (mode === "bleed") {
      return {
        enabled: {
          ...muted.enabled,
          border: muted.enabled.bg
        },
        hovered: {
          ...muted.hovered,
          border: muted.hovered.bg
        },
        pressed: {
          ...muted.pressed,
          border: muted.pressed.bg
        },
        selected: {
          ...muted.selected,
          border: muted.selected.bg
        },
        disabled: {
          ...muted.disabled,
          border: muted.disabled.bg
        }
      };
    }
    if (mode === "ghost") {
      return {
        ...solid,
        enabled: {
          ...muted.enabled,
          border: base.border
        },
        disabled: muted.disabled
      };
    }
    return solid;
  },
  card: (_ref15) => {
    let {
      base,
      dark,
      muted,
      name,
      solid,
      state
    } = _ref15;
    if (state === "hovered") {
      return muted[name].hovered;
    }
    if (state === "disabled") {
      return muted[name].disabled;
    }
    const isNeutral = NEUTRAL_TONES.includes(name);
    const tints = tones[name] || tones.default;
    const mix = dark ? screen : multiply;
    if (state === "pressed") {
      if (isNeutral) {
        return muted.primary.pressed;
      }
      return muted[name].pressed;
    }
    if (state === "selected") {
      if (isNeutral) {
        return solid.primary.enabled;
      }
      return solid[name].enabled;
    }
    const bg = base.bg;
    const skeletonFrom = mix(base.bg, tints[dark ? 900 : 100].hex);
    return {
      bg,
      bg2: mix(bg, tints[dark ? 950 : 50].hex),
      fg: base.fg,
      border: base.border,
      muted: {
        fg: mix(base.bg, tints[dark ? 400 : 600].hex)
      },
      accent: {
        fg: mix(base.bg, hues.red[dark ? 400 : 500].hex)
      },
      link: {
        fg: mix(base.bg, hues.blue[dark ? 400 : 600].hex)
      },
      code: {
        bg: mix(base.bg, tints[dark ? 950 : 50].hex),
        fg: tints[dark ? 400 : 600].hex
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba(skeletonFrom, 0.5)
      }
    };
  },
  input: (_ref16) => {
    let {
      base,
      dark,
      mode,
      state
    } = _ref16;
    const mix = dark ? screen : multiply;
    if (mode === "invalid") {
      const tints = tones.critical;
      return {
        bg: mix(base.bg, tints[dark ? 950 : 50].hex),
        fg: mix(base.bg, tints[dark ? 400 : 600].hex),
        border: mix(base.bg, tints[dark ? 800 : 200].hex),
        placeholder: mix(base.bg, tints[dark ? 600 : 400].hex)
      };
    }
    if (state === "hovered") {
      return {
        bg: base.bg,
        fg: base.fg,
        border: mix(base.bg, hues.gray[dark ? 700 : 300].hex),
        placeholder: mix(base.bg, hues.gray[dark ? 600 : 400].hex)
      };
    }
    if (state === "disabled") {
      return {
        bg: mix(base.bg, hues.gray[dark ? 950 : 50].hex),
        fg: mix(base.bg, hues.gray[dark ? 700 : 300].hex),
        border: mix(base.bg, hues.gray[dark ? 900 : 100].hex),
        placeholder: mix(base.bg, hues.gray[dark ? 800 : 200].hex)
      };
    }
    if (state === "readOnly") {
      return {
        bg: mix(base.bg, hues.gray[dark ? 950 : 50].hex),
        fg: mix(base.bg, hues.gray[dark ? 200 : 800].hex),
        border: mix(base.bg, hues.gray[dark ? 800 : 200].hex),
        placeholder: mix(base.bg, hues.gray[dark ? 600 : 400].hex)
      };
    }
    return {
      bg: base.bg,
      fg: base.fg,
      border: base.border,
      placeholder: mix(base.bg, hues.gray[dark ? 600 : 400].hex)
    };
  },
  selectable: (_ref17) => {
    let {
      base,
      muted,
      tone,
      solid,
      state
    } = _ref17;
    if (state === "enabled") {
      return {
        ...muted[tone].enabled,
        bg: base.bg
      };
    }
    if (state === "pressed") {
      if (tone === "default") {
        return muted.primary.pressed;
      }
      return muted[tone].pressed;
    }
    if (state === "selected") {
      if (tone === "default") {
        return solid.primary.enabled;
      }
      return solid[tone].enabled;
    }
    if (state === "disabled") {
      return {
        ...muted[tone].disabled,
        bg: base.bg
      };
    }
    return muted[tone][state];
  },
  spot: (_ref18) => {
    let {
      base,
      dark,
      key: key2
    } = _ref18;
    const mix = dark ? screen : multiply;
    return mix(base.bg, hues[key2][dark ? 400 : 500].hex);
  },
  syntax: (_ref19) => {
    let {
      base,
      dark
    } = _ref19;
    const mix = dark ? screen : multiply;
    const mainShade = dark ? 400 : 600;
    const secondaryShade = dark ? 600 : 400;
    return {
      atrule: mix(base.bg, hues.purple[mainShade].hex),
      attrName: mix(base.bg, hues.green[mainShade].hex),
      attrValue: mix(base.bg, hues.yellow[mainShade].hex),
      attribute: mix(base.bg, hues.yellow[mainShade].hex),
      boolean: mix(base.bg, hues.purple[mainShade].hex),
      builtin: mix(base.bg, hues.purple[mainShade].hex),
      cdata: mix(base.bg, hues.yellow[mainShade].hex),
      char: mix(base.bg, hues.yellow[mainShade].hex),
      class: mix(base.bg, hues.orange[mainShade].hex),
      className: mix(base.bg, hues.cyan[mainShade].hex),
      comment: mix(base.bg, hues.gray[secondaryShade].hex),
      constant: mix(base.bg, hues.purple[mainShade].hex),
      deleted: mix(base.bg, hues.red[mainShade].hex),
      doctype: mix(base.bg, hues.gray[secondaryShade].hex),
      entity: mix(base.bg, hues.red[mainShade].hex),
      function: mix(base.bg, hues.green[mainShade].hex),
      hexcode: mix(base.bg, hues.blue[mainShade].hex),
      id: mix(base.bg, hues.purple[mainShade].hex),
      important: mix(base.bg, hues.purple[mainShade].hex),
      inserted: mix(base.bg, hues.yellow[mainShade].hex),
      keyword: mix(base.bg, hues.magenta[mainShade].hex),
      number: mix(base.bg, hues.purple[mainShade].hex),
      operator: mix(base.bg, hues.magenta[mainShade].hex),
      prolog: mix(base.bg, hues.gray[secondaryShade].hex),
      property: mix(base.bg, hues.blue[mainShade].hex),
      pseudoClass: mix(base.bg, hues.yellow[mainShade].hex),
      pseudoElement: mix(base.bg, hues.yellow[mainShade].hex),
      punctuation: mix(base.bg, hues.gray[mainShade].hex),
      regex: mix(base.bg, hues.blue[mainShade].hex),
      selector: mix(base.bg, hues.red[mainShade].hex),
      string: mix(base.bg, hues.yellow[mainShade].hex),
      symbol: mix(base.bg, hues.purple[mainShade].hex),
      tag: mix(base.bg, hues.red[mainShade].hex),
      unit: mix(base.bg, hues.orange[mainShade].hex),
      url: mix(base.bg, hues.red[mainShade].hex),
      variable: mix(base.bg, hues.red[mainShade].hex)
    };
  }
});
var DEFAULT_THEME_LAYER = {
  dialog: {
    zOffset: 600
  },
  popover: {
    zOffset: 400
  },
  tooltip: {
    zOffset: 200
  }
};
function getGlobalScope() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof window !== "undefined")
    return window;
  if (typeof self !== "undefined")
    return self;
  if (typeof global !== "undefined")
    return global;
  throw new Error("@sanity/ui: could not locate global scope");
}
var globalScope = getGlobalScope();
var key$8 = Symbol.for("@sanity/ui/context/theme");
globalScope[key$8] = globalScope[key$8] || (0, import_react2.createContext)(null);
var ThemeContext = globalScope[key$8];
function ThemeProvider(props) {
  const parentTheme = (0, import_react2.useContext)(ThemeContext);
  const {
    children,
    scheme = (parentTheme == null ? void 0 : parentTheme.scheme) || "light",
    theme: themeProp = (parentTheme == null ? void 0 : parentTheme.theme) || null,
    tone = (parentTheme == null ? void 0 : parentTheme.tone) || "default"
  } = props;
  const theme = (0, import_react2.useMemo)(() => {
    if (!themeProp)
      return null;
    const {
      color: rootColor,
      layer: rootLayer,
      ...restTheme
    } = themeProp;
    const colorScheme = rootColor[scheme] || rootColor.light;
    const color2 = colorScheme[tone] || colorScheme.default;
    const layer = rootLayer || DEFAULT_THEME_LAYER;
    return {
      sanity: {
        ...restTheme,
        color: color2,
        layer
      }
    };
  }, [scheme, themeProp, tone]);
  const value = (0, import_react2.useMemo)(() => themeProp && {
    version: 0,
    theme: themeProp,
    scheme,
    tone
  }, [themeProp, scheme, tone]);
  if (!theme) {
    return (0, import_jsx_runtime.jsx)("pre", {
      children: 'ThemeProvider: no "theme" property provided'
    });
  }
  return (0, import_jsx_runtime.jsx)(ThemeContext.Provider, {
    value,
    children: (0, import_jsx_runtime.jsx)(Le, {
      theme,
      children
    })
  });
}
function isRecord(value) {
  return Boolean(value && typeof value === "object");
}
function useRootTheme() {
  const value = (0, import_react2.useContext)(ThemeContext);
  if (!value) {
    throw new Error("useRootTheme(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("useRootTheme(): the context value is not compatible");
  }
  return value;
}
function ThemeColorProvider(props) {
  const {
    children,
    scheme,
    tone
  } = props;
  const root = useRootTheme();
  return (0, import_jsx_runtime.jsx)(ThemeProvider, {
    scheme: scheme || root.scheme,
    theme: root.theme,
    tone,
    children
  });
}
function useTheme() {
  return Xe();
}
var MEDIA_STORE_CACHE = /* @__PURE__ */ new WeakMap();
function _getMediaQuery(media, index2) {
  if (index2 === 0) {
    return "screen and (max-width: ".concat(media[index2] - 1, "px)");
  }
  if (index2 === media.length) {
    return "screen and (min-width: ".concat(media[index2 - 1], "px)");
  }
  return "screen and (min-width: ".concat(media[index2 - 1], "px) and (max-width: ").concat(media[index2] - 1, "px)");
}
function _createMediaStore(media) {
  const mediaLen = media.length;
  let sizes;
  const getSizes = () => {
    if (!sizes) {
      sizes = [];
      for (let index2 = mediaLen; index2 > -1; index2 -= 1) {
        const mediaQuery = _getMediaQuery(media, index2);
        sizes.push({
          index: index2,
          mq: window.matchMedia(mediaQuery)
        });
      }
    }
    return sizes;
  };
  const getSnapshot = () => {
    for (const {
      index: index2,
      mq
    } of getSizes()) {
      if (mq.matches)
        return index2;
    }
    return 0;
  };
  const subscribe = (onStoreChange) => {
    const disposeFns = [];
    for (const {
      mq
    } of getSizes()) {
      const handleChange = () => {
        if (mq.matches)
          onStoreChange();
      };
      mq.addEventListener("change", handleChange);
      disposeFns.push(() => mq.removeEventListener("change", handleChange));
    }
    return () => {
      for (const disposeFn of disposeFns) {
        disposeFn();
      }
    };
  };
  return {
    getSnapshot,
    subscribe
  };
}
function getServerSnapshot$2() {
  return 0;
}
function useMediaIndex() {
  const theme = useTheme();
  const {
    media
  } = theme.sanity;
  let store = MEDIA_STORE_CACHE.get(media);
  if (!store) {
    store = _createMediaStore(media);
    MEDIA_STORE_CACHE.set(media, store);
  }
  return (0, import_react2.useSyncExternalStore)(store.subscribe, store.getSnapshot, getServerSnapshot$2);
}
var useIsomorphicEffect = typeof window !== "undefined" ? import_react2.useLayoutEffect : import_react2.useEffect;
function useForwardedRef(ref) {
  const innerRef = (0, import_react2.useRef)(null);
  useIsomorphicEffect(() => {
    if (!ref)
      return;
    if (typeof ref === "function") {
      ref(innerRef.current);
    } else {
      ref.current = innerRef.current;
    }
  });
  return innerRef;
}
function useCustomValidity(ref, customValidity) {
  (0, import_react2.useEffect)(() => {
    if (ref.current) {
      ref.current.setCustomValidity(customValidity || "");
    }
  }, [customValidity, ref]);
}
var BORDER_VALUE = "1px solid var(--card-border-color)";
function responsiveBorderStyle() {
  return [border, borderTop, borderRight, borderBottom, borderLeft];
}
function border(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$border, (value) => value ? {
    "&&": {
      border: BORDER_VALUE
    }
  } : {
    "&&": {
      border: 0
    }
  });
}
function borderTop(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$borderTop, (value) => value ? {
    "&&": {
      borderTop: BORDER_VALUE
    }
  } : {
    "&&": {
      borderTop: 0
    }
  });
}
function borderRight(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$borderRight, (value) => value ? {
    "&&": {
      borderRight: BORDER_VALUE
    }
  } : {
    "&&": {
      borderRight: 0
    }
  });
}
function borderBottom(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$borderBottom, (value) => value ? {
    "&&": {
      borderBottom: BORDER_VALUE
    }
  } : {
    "&&": {
      borderBottom: 0
    }
  });
}
function borderLeft(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$borderLeft, (value) => value ? {
    "&&": {
      borderLeft: BORDER_VALUE
    }
  } : {
    "&&": {
      borderLeft: 0
    }
  });
}
var BASE_STYLE$4 = {
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
};
var BOX_SIZING = {
  content: "content-box",
  border: "border-box"
};
var BOX_HEIGHT = {
  stretch: "stretch",
  fill: "100%"
};
function boxStyle() {
  return BASE_STYLE$4;
}
function responsiveBoxStyle() {
  return [responsiveBoxSizingStyle, responsiveBoxHeightStyle, responsiveBoxOverflowStyle, responsiveBoxDisplayStyle];
}
function responsiveBoxDisplayStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$display, (display) => ({
    "&:not([hidden])": {
      display
    }
  }));
}
function responsiveBoxSizingStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$sizing, (sizing) => ({
    boxSizing: BOX_SIZING[sizing]
  }));
}
function responsiveBoxHeightStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$height, (height) => ({
    height: BOX_HEIGHT[height]
  }));
}
function responsiveBoxOverflowStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$overflow, (overflow) => ({
    overflow
  }));
}
var BASE_STYLE$3 = {
  "&&:not([hidden])": {
    display: "flex"
  }
};
function responsiveFlexStyle() {
  return [BASE_STYLE$3, responsiveFlexAlignStyle, responsiveFlexGapStyle, responsiveFlexWrapStyle, responsiveFlexJustifyStyle, responsiveFlexDirectionStyle];
}
function responsiveFlexAlignStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$align, (align) => {
    return {
      alignItems: align
    };
  });
}
function responsiveFlexGapStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$gap, (gap) => ({
    gap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveFlexWrapStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$wrap, (wrap) => {
    return {
      flexWrap: wrap
    };
  });
}
function responsiveFlexJustifyStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$justify, (justify) => {
    return {
      justifyContent: justify
    };
  });
}
function responsiveFlexDirectionStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$direction, (direction) => {
    return {
      flexDirection: direction
    };
  });
}
var BASE_STYLE$2 = {
  minWidth: 0,
  minHeight: 0
};
function flexItemStyle() {
  return [BASE_STYLE$2, responsiveFlexItemStyle];
}
function responsiveFlexItemStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  if (!props.$flex)
    return EMPTY_ARRAY;
  return _responsive(media, props.$flex, (flex) => ({
    flex
  }));
}
function focusRingBorderStyle(border2) {
  return "inset 0 0 0 ".concat(border2.width, "px ").concat(border2.color);
}
function focusRingStyle(opts) {
  const {
    base,
    border: border2,
    focusRing
  } = opts;
  const focusRingOutsetWidth = focusRing.offset + focusRing.width;
  const focusRingInsetWidth = 0 - focusRing.offset;
  const bgColor = base ? base.bg : "var(--card-bg-color)";
  return [focusRingInsetWidth > 0 && "inset 0 0 0 ".concat(focusRingInsetWidth, "px var(--card-focus-ring-color)"), border2 && focusRingBorderStyle(border2), focusRingInsetWidth < 0 && "0 0 0 ".concat(0 - focusRingInsetWidth, "px ").concat(bgColor), focusRingOutsetWidth > 0 && "0 0 0 ".concat(focusRingOutsetWidth, "px var(--card-focus-ring-color)")].filter(Boolean).join(",");
}
var GRID_CSS = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
};
var GRID_AUTO_COLUMS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
var GRID_AUTO_ROWS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
function responsiveGridStyle() {
  return [GRID_CSS, responsiveGridAutoFlowStyle, responsiveGridAutoRowsStyle, responsiveGridAutoColsStyle, responsiveGridColumnsStyle, responsiveGridRowsStyle, responsiveGridGapStyle, responsiveGridGapXStyle, responsiveGridGapYStyle];
}
function responsiveGridAutoFlowStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$autoFlow, (autoFlow) => ({
    gridAutoFlow: autoFlow
  }));
}
function responsiveGridAutoRowsStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$autoRows, (autoRows) => ({
    gridAutoRows: autoRows && GRID_AUTO_ROWS[autoRows]
  }));
}
function responsiveGridAutoColsStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$autoCols, (autoCols) => ({
    gridAutoColumns: autoCols && GRID_AUTO_COLUMS[autoCols]
  }));
}
function responsiveGridColumnsStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$columns, (columns) => ({
    gridTemplateColumns: columns && "repeat(".concat(columns, ",minmax(0,1fr));")
  }));
}
function responsiveGridRowsStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$rows, (rows) => ({
    gridTemplateRows: rows && "repeat(".concat(rows, ",minmax(0,1fr));")
  }));
}
function responsiveGridGapStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$gap, (gap) => ({
    gridGap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveGridGapXStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$gapX, (gapX) => ({
    columnGap: gapX ? rem(space[gapX]) : void 0
  }));
}
function responsiveGridGapYStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$gapY, (gapY) => ({
    rowGap: gapY ? rem(space[gapY]) : void 0
  }));
}
function responsiveGridItemStyle() {
  return [responsiveGridItemRowStyle, responsiveGridItemRowStartStyle, responsiveGridItemRowEndStyle, responsiveGridItemColumnStyle, responsiveGridItemColumnStartStyle, responsiveGridItemColumnEndStyle];
}
var GRID_ITEM_ROW = {
  auto: "auto",
  full: "1 / -1"
};
var GRID_ITEM_COLUMN = {
  auto: "auto",
  full: "1 / -1"
};
function responsiveGridItemRowStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$row, (row) => {
    if (typeof row === "number") {
      return {
        gridRow: "span ".concat(row, " / span ").concat(row)
      };
    }
    return {
      gridRow: GRID_ITEM_ROW[row]
    };
  });
}
function responsiveGridItemRowStartStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$rowStart, (rowStart) => ({
    gridRowStart: rowStart
  }));
}
function responsiveGridItemRowEndStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$rowEnd, (rowEnd) => ({
    gridRowEnd: rowEnd
  }));
}
function responsiveGridItemColumnStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$column, (column) => {
    if (typeof column === "number") {
      return {
        gridColumn: "span ".concat(column, " / span ").concat(column)
      };
    }
    return {
      gridColumn: GRID_ITEM_COLUMN[column]
    };
  });
}
function responsiveGridItemColumnStartStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$columnStart, (columnStart) => ({
    gridColumnStart: columnStart
  }));
}
function responsiveGridItemColumnEndStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$columnEnd, (columnEnd) => ({
    gridColumnEnd: columnEnd
  }));
}
function responsiveInputPaddingStyle(props) {
  const {
    $fontSize,
    $iconLeft,
    $iconRight,
    $padding,
    $space,
    theme
  } = props;
  const {
    fonts,
    media,
    space: spaceScale
  } = theme.sanity;
  const len = Math.max($padding.length, $space.length, $fontSize.length);
  const _padding = [];
  const _space = [];
  const _fontSize = [];
  for (let i = 0; i < len; i += 1) {
    _fontSize[i] = $fontSize[i] === void 0 ? _fontSize[i - 1] : $fontSize[i];
    _padding[i] = $padding[i] === void 0 ? _padding[i - 1] : $padding[i];
    _space[i] = $space[i] === void 0 ? _space[i - 1] : $space[i];
  }
  return _responsive(media, _padding, (_, i) => {
    const size3 = fonts.text.sizes[_fontSize[i]] || fonts.text.sizes[2];
    const emSize = size3.lineHeight - size3.ascenderHeight - size3.descenderHeight;
    const p = spaceScale[_padding[i]];
    const s = spaceScale[_space[i]];
    const styles = {
      paddingTop: rem(p - size3.ascenderHeight),
      paddingRight: rem(p),
      paddingBottom: rem(p - size3.descenderHeight),
      paddingLeft: rem(p)
    };
    if ($iconRight)
      styles.paddingRight = rem(p + emSize + s);
    if ($iconLeft)
      styles.paddingLeft = rem(p + emSize + s);
    return styles;
  });
}
function responsiveInputPaddingIconRightStyle(props) {
  return responsiveInputPaddingStyle({
    ...props,
    $iconRight: true
  });
}
var __freeze$D = Object.freeze;
var __defProp$E = Object.defineProperty;
var __template$D = (cooked, raw) => __freeze$D(__defProp$E(cooked, "raw", {
  value: __freeze$D(raw || cooked.slice())
}));
var _a$D;
var _b$m;
var _c$d;
var ROOT_STYLE = Ae(_a$D || (_a$D = __template$D(["\n  &:not([hidden]) {\n    display: flex;\n  }\n\n  align-items: center;\n"])));
function textInputRootStyle() {
  return ROOT_STYLE;
}
function textInputBaseStyle(props) {
  const {
    theme,
    $scheme,
    $tone,
    $weight
  } = props;
  const font = theme.sanity.fonts.text;
  const color2 = theme.sanity.color.input;
  return Ae(_b$m || (_b$m = __template$D(["\n    appearance: none;\n    background: none;\n    border: 0;\n    border-radius: 0;\n    outline: none;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: ", ";\n    font-weight: ", ";\n    margin: 0;\n    position: relative;\n    z-index: 1;\n    display: block;\n\n    /* NOTE: This is a hack to disable Chromes autofill styles */\n    &:-webkit-autofill,\n    &:-webkit-autofill:hover,\n    &:-webkit-autofill:focus,\n    &:-webkit-autofill:active {\n      -webkit-text-fill-color: var(--input-fg-color) !important;\n      transition: background-color 5000s;\n      transition-delay: 86400s /* 24h */;\n    }\n\n    /* &:is(textarea) */\n    &[data-as='textarea'] {\n      resize: none;\n    }\n\n    color: var(--input-fg-color);\n\n    &::placeholder {\n      color: var(--input-placeholder-color);\n    }\n\n    &[data-scheme='", "'][data-tone='", "'] {\n      --input-fg-color: ", ";\n      --input-placeholder-color: ", ";\n\n      /* enabled */\n      &:not(:invalid):not(:disabled):not(:read-only) {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* disabled */\n      &:not(:invalid):disabled {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* invalid */\n      &:invalid {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* readOnly */\n      &:read-only {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n    }\n  "])), font.family, $weight && font.weights[$weight] || font.weights.regular, $scheme, $tone, color2.default.enabled.fg, color2.default.enabled.placeholder, color2.default.enabled.fg, color2.default.enabled.placeholder, color2.default.disabled.fg, color2.default.disabled.placeholder, color2.invalid.enabled.fg, color2.invalid.enabled.placeholder, color2.default.readOnly.fg, color2.default.readOnly.placeholder);
}
function textInputFontSizeStyle(props) {
  const {
    theme
  } = props;
  const {
    fonts,
    media
  } = theme.sanity;
  return _responsive(media, props.$fontSize, (sizeIndex) => {
    const size3 = fonts.text.sizes[sizeIndex] || fonts.text.sizes[2];
    return {
      fontSize: rem(size3.fontSize),
      lineHeight: size3.lineHeight / size3.fontSize
    };
  });
}
function textInputRepresentationStyle(props) {
  const {
    $hasPrefix,
    $hasSuffix,
    $scheme,
    $tone,
    theme
  } = props;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color2 = theme.sanity.color.input;
  return Ae(_c$d || (_c$d = __template$D(["\n    --input-box-shadow: none;\n\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    display: block;\n    pointer-events: none;\n    z-index: 0;\n\n    background-color: var(--card-bg-color);\n    box-shadow: var(--input-box-shadow);\n\n    border-top-left-radius: ", ";\n    border-bottom-left-radius: ", ";\n    border-top-right-radius: ", ";\n    border-bottom-right-radius: ", ";\n\n    &[data-scheme='", "'][data-tone='", "'] {\n      --card-bg-color: ", ";\n      --card-fg-color: ", ";\n\n      /* enabled */\n      *:not(:disabled) + &[data-border] {\n        --input-box-shadow: ", ";\n      }\n\n      /* invalid */\n      *:not(:disabled):invalid + & {\n        --card-bg-color: ", ";\n        --card-fg-color: ", ";\n\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* focused */\n      *:not(:disabled):focus + & {\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n\n        &:not([data-border]) {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* disabled */\n      *:disabled + & {\n        --card-bg-color: ", " !important;\n        --card-fg-color: ", " !important;\n\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* readOnly */\n      *:read-only + & {\n        --card-bg-color: ", " !important;\n        --card-fg-color: ", " !important;\n      }\n\n      /* hovered */\n      @media (hover: hover) {\n        *:not(:disabled):not(:read-only):not(:invalid):hover + & {\n          --card-bg-color: ", ";\n          --card-fg-color: ", ";\n        }\n\n        *:not(:disabled):not(:read-only):not(:invalid):not(:focus):hover + &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n    }\n  "])), $hasPrefix ? 0 : void 0, $hasPrefix ? 0 : void 0, $hasSuffix ? 0 : void 0, $hasSuffix ? 0 : void 0, $scheme, $tone, color2.default.enabled.bg, color2.default.enabled.fg, focusRingBorderStyle({
    color: color2.default.enabled.border,
    width: input.border.width
  }), color2.invalid.enabled.bg, color2.invalid.enabled.fg, focusRingBorderStyle({
    color: color2.invalid.enabled.border,
    width: input.border.width
  }), focusRingStyle({
    border: {
      color: color2.default.enabled.border,
      width: input.border.width
    },
    focusRing
  }), focusRingStyle({
    focusRing
  }), color2.default.disabled.bg, color2.default.disabled.fg, focusRingBorderStyle({
    color: color2.default.disabled.border,
    width: input.border.width
  }), color2.default.readOnly.bg, color2.default.readOnly.fg, color2.default.hovered.bg, color2.default.hovered.fg, focusRingBorderStyle({
    color: color2.default.hovered.border,
    width: input.border.width
  }));
}
function responsiveMarginStyle(props) {
  const {
    theme
  } = props;
  return [_getResponsiveSpace(theme, ["margin"], props.$margin), _getResponsiveSpace(theme, ["marginLeft", "marginRight"], props.$marginX), _getResponsiveSpace(theme, ["marginTop", "marginBottom"], props.$marginY), _getResponsiveSpace(theme, ["marginTop"], props.$marginTop), _getResponsiveSpace(theme, ["marginRight"], props.$marginRight), _getResponsiveSpace(theme, ["marginBottom"], props.$marginBottom), _getResponsiveSpace(theme, ["marginLeft"], props.$marginLeft)].filter(Boolean);
}
function responsivePaddingStyle(props) {
  const {
    theme
  } = props;
  return [_getResponsiveSpace(theme, ["padding"], props.$padding), _getResponsiveSpace(theme, ["paddingLeft", "paddingRight"], props.$paddingX), _getResponsiveSpace(theme, ["paddingTop", "paddingBottom"], props.$paddingY), _getResponsiveSpace(theme, ["paddingTop"], props.$paddingTop), _getResponsiveSpace(theme, ["paddingRight"], props.$paddingRight), _getResponsiveSpace(theme, ["paddingBottom"], props.$paddingBottom), _getResponsiveSpace(theme, ["paddingLeft"], props.$paddingLeft)].filter(Boolean);
}
function responsiveRadiusStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    radius
  } = theme.sanity;
  return _responsive(media, props.$radius, (radiusIndex) => ({
    borderRadius: rem(radius[radiusIndex])
  }));
}
function toBoxShadow(shadow, color2) {
  return "".concat(shadow.map(rem).join(" "), " ").concat(color2);
}
function shadowStyle(shadow) {
  if (!shadow)
    return EMPTY_RECORD;
  const outline = "0 0 0 ".concat(rem(1), " var(--card-shadow-outline-color)");
  const umbra = toBoxShadow(shadow.umbra, "var(--card-shadow-umbra-color)");
  const penumbra = toBoxShadow(shadow.penumbra, "var(--card-shadow-penumbra-color)");
  const ambient = toBoxShadow(shadow.ambient, "var(--card-shadow-ambient-color)");
  return {
    boxShadow: "".concat(outline, ", ").concat(umbra, ", ").concat(penumbra, ", ").concat(ambient)
  };
}
function responsiveShadowStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    shadows
  } = theme.sanity;
  return _responsive(media, props.$shadow, (shadow) => shadowStyle(shadows[shadow]));
}
var __freeze$C = Object.freeze;
var __defProp$D = Object.defineProperty;
var __template$C = (cooked, raw) => __freeze$C(__defProp$D(cooked, "raw", {
  value: __freeze$C(raw || cooked.slice())
}));
var _a$C;
var _b$l;
var _c$c;
function textBaseStyle(props) {
  const {
    $accent,
    $muted,
    theme
  } = props;
  const {
    weights
  } = theme.sanity.fonts.text;
  return Ae(_c$c || (_c$c = __template$C(["\n    color: var(--card-fg-color);\n\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n      background-color: var(--card-code-bg-color);\n      color: var(--card-code-fg-color);\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n      color: var(--card-link-color);\n      outline: none;\n\n      @media (hover: hover) {\n        &:hover {\n          text-decoration: underline;\n        }\n      }\n\n      &:focus {\n        box-shadow:\n          0 0 0 1px var(--card-bg-color),\n          0 0 0 3px var(--card-focus-ring-color);\n      }\n\n      &:focus:not(:focus-visible) {\n        box-shadow: none;\n      }\n    }\n\n    & strong {\n      font-weight: ", ";\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), $accent && Ae(_a$C || (_a$C = __template$C(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && Ae(_b$l || (_b$l = __template$C(["\n      color: var(--card-muted-fg-color);\n    "]))), theme.sanity.fonts.code.family, weights.bold);
}
var __freeze$B = Object.freeze;
var __defProp$C = Object.defineProperty;
var __template$B = (cooked, raw) => __freeze$B(__defProp$C(cooked, "raw", {
  value: __freeze$B(raw || cooked.slice())
}));
var _a$B;
var Root$E = styled_components_browser_esm_default.div(responsiveTextFont, responsiveTextAlignStyle, textBaseStyle);
var SpanWithTextOverflow$2 = styled_components_browser_esm_default.span(_a$B || (_a$B = __template$B(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  overflow: clip;\n"])));
var Text = (0, import_react2.forwardRef)(function Text2(props, ref) {
  const {
    accent = false,
    align,
    children: childrenProp,
    muted = false,
    size: size3 = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = (0, import_jsx_runtime.jsx)(SpanWithTextOverflow$2, {
      children
    });
  }
  return (0, import_jsx_runtime.jsx)(Root$E, {
    "data-ui": "Text",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align),
    $muted: muted,
    ref,
    $size: useArrayProp(size3),
    $weight: weight,
    children: (0, import_jsx_runtime.jsx)("span", {
      children
    })
  });
});
var avatarStyle = {
  root: avatarRootStyle,
  arrow: avatarArrowStyle,
  bgStroke: avatarBgStrokeStyle,
  stroke: avatarStrokeStyle,
  initials: avatarInitialsStyle
};
function avatarArrowStyle() {
  return {
    position: "absolute",
    boxSizing: "border-box",
    zIndex: 0,
    opacity: 0,
    transition: "all 0.2s linear",
    transform: "rotate(-90deg) translate3d(0, 6px, 0)",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    "& > svg": {
      width: "11px",
      height: "7px",
      position: "absolute",
      top: "-5px",
      left: "50%",
      transform: "translateX(-6px)",
      // @ts-expect-error -- TODO wait for CSSObject types to be fixed in `styled-components` itself
      "&:not([hidden])": {
        display: "block"
      }
    },
    "[data-arrow-position='inside'] > &": {
      transform: "rotate(-90deg) translate3d(0, 6px, 0)",
      opacity: 0
    },
    "[data-arrow-position='top'] > &": {
      opacity: 1,
      transform: "rotate(0deg)"
    },
    "[data-arrow-position='bottom'] > &": {
      opacity: 1,
      transform: "rotate(-180deg)"
    }
  };
}
function avatarRootStyle(props) {
  const {
    $color,
    theme
  } = props;
  const {
    focusRing
  } = theme.sanity;
  return {
    backgroundColor: $color,
    position: "relative",
    boxSizing: "border-box",
    userSelect: "none",
    boxShadow: "0 0 0 1px var(--card-bg-color)",
    '&[data-status="inactive"]': {
      opacity: 0.5
    },
    "&>svg": {
      // @ts-expect-error -- TODO wait for CSSObject types to be fixed in `styled-components` itself
      "&:not([hidden])": {
        display: "block"
      }
    },
    /* &:is(button) */
    '&[data-as="button"]': {
      WebkitFontSmoothing: "inherit",
      appearance: "none",
      margin: 0,
      padding: 0,
      border: 0,
      font: "inherit",
      color: "inherit",
      outline: "none",
      // @ts-expect-error -- TODO wait for CSSObject types to be fixed in `styled-components` itself
      "&:focus": {
        boxShadow: focusRingStyle({
          focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: "none"
      }
    }
  };
}
function responsiveAvatarSizeStyle(props) {
  const {
    theme
  } = props;
  const {
    avatar,
    media
  } = theme.sanity;
  return _responsive(media, props.$size, (size3) => {
    const avatarSize = avatar.sizes[size3] || avatar.sizes[0];
    return {
      width: rem(avatarSize.size),
      height: rem(avatarSize.size),
      borderRadius: rem(avatarSize.size / 2),
      "&>svg": {
        width: rem(avatarSize.size),
        height: rem(avatarSize.size),
        borderRadius: rem(avatarSize.size / 2)
      }
    };
  });
}
function avatarInitialsStyle(props) {
  const {
    theme
  } = props;
  const {
    base
  } = theme.sanity.color;
  return {
    width: "100%",
    height: "100%",
    color: base.fg,
    alignItems: "center",
    justifyContent: "center",
    textTransform: "uppercase",
    textAlign: "center",
    borderRadius: "50%",
    "&:not([hidden])": {
      display: "flex"
    }
  };
}
function avatarBgStrokeStyle() {
  return {
    strokeWidth: "4px",
    stroke: "var(--card-bg-color)"
  };
}
function avatarStrokeStyle() {
  return {
    strokeWidth: "3px",
    '[data-status="editing"] &': {
      strokeDasharray: "2 4",
      strokeLinecap: "round"
    }
  };
}
var Root$D = styled_components_browser_esm_default.div(responsiveAvatarSizeStyle, avatarStyle.root);
var Arrow = styled_components_browser_esm_default.div(avatarStyle.arrow);
var BgStroke = styled_components_browser_esm_default.ellipse(avatarStyle.bgStroke);
var Stroke = styled_components_browser_esm_default.ellipse(avatarStyle.stroke);
var Initials = styled_components_browser_esm_default.div(avatarStyle.initials);
var Avatar = (0, import_react2.forwardRef)(function Avatar2(props, ref) {
  const {
    as: asProp,
    color: colorKey = "gray",
    src,
    title,
    initials,
    onImageLoadError,
    arrowPosition: arrowPositionProp,
    animateArrowFrom,
    status = "online",
    size: sizeProp = 0,
    ...restProps
  } = props;
  const as = import_react_is.default.isValidElementType(asProp) ? asProp : "div";
  const size3 = useArrayProp(sizeProp);
  const theme = useTheme();
  const color2 = theme.sanity.color.spot[colorKey] || theme.sanity.color.spot.gray;
  const avatarSize = theme.sanity.avatar.sizes[size3[0]] || theme.sanity.avatar.sizes[0];
  const _sizeRem = avatarSize.size;
  const _radius = _sizeRem / 2;
  const elementId = (0, import_react2.useId)();
  const [arrowPosition, setArrowPosition] = (0, import_react2.useState)(animateArrowFrom || arrowPositionProp || "inside");
  const [imageFailed, setImageFailed] = (0, import_react2.useState)(false);
  const imageId = "avatar-image-".concat(elementId);
  (0, import_react2.useEffect)(() => {
    if (arrowPosition === arrowPositionProp)
      return void 0;
    const raf = requestAnimationFrame(() => setArrowPosition(arrowPositionProp));
    return () => cancelAnimationFrame(raf);
  }, [arrowPosition, arrowPositionProp]);
  (0, import_react2.useEffect)(() => {
    if (src)
      setImageFailed(false);
  }, [src]);
  const handleImageError = (0, import_react2.useCallback)(() => {
    setImageFailed(true);
    if (onImageLoadError) {
      onImageLoadError(new Error("Avatar: the image failed to load"));
    }
  }, [onImageLoadError]);
  const initialsSize = (0, import_react2.useMemo)(() => size3.map((s) => s === 0 ? 0 : s + 1), [size3]);
  return (0, import_jsx_runtime.jsxs)(Root$D, {
    as,
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Avatar",
    ...restProps,
    $size: size3,
    $color: color2,
    "aria-label": title,
    "data-arrow-position": arrowPosition,
    "data-status": status,
    ref,
    title,
    children: [(0, import_jsx_runtime.jsx)(Arrow, {
      children: (0, import_jsx_runtime.jsx)("svg", {
        width: "11",
        height: "7",
        viewBox: "0 0 11 7",
        fill: "none",
        children: (0, import_jsx_runtime.jsx)("path", {
          d: "M6.67948 1.50115L11 7L0 7L4.32052 1.50115C4.92109 0.736796 6.07891 0.736795 6.67948 1.50115Z",
          fill: color2
        })
      })
    }), !imageFailed && src && (0, import_jsx_runtime.jsxs)("svg", {
      viewBox: "0 0 ".concat(_sizeRem, " ").concat(_sizeRem),
      fill: "none",
      children: [(0, import_jsx_runtime.jsx)("defs", {
        children: (0, import_jsx_runtime.jsx)("pattern", {
          id: imageId,
          patternContentUnits: "objectBoundingBox",
          width: "1",
          height: "1",
          children: (0, import_jsx_runtime.jsx)("image", {
            href: src,
            width: "1",
            height: "1",
            onError: handleImageError
          })
        })
      }), (0, import_jsx_runtime.jsx)("circle", {
        cx: _radius,
        cy: _radius,
        r: _radius,
        fill: "url(#".concat(imageId, ")")
      }), (0, import_jsx_runtime.jsx)(BgStroke, {
        cx: _radius,
        cy: _radius,
        rx: _radius,
        ry: _radius,
        vectorEffect: "non-scaling-stroke"
      }), (0, import_jsx_runtime.jsx)(Stroke, {
        cx: _radius,
        cy: _radius,
        rx: _radius,
        ry: _radius,
        stroke: color2,
        vectorEffect: "non-scaling-stroke"
      })]
    }), (imageFailed || !src) && initials && (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
      children: (0, import_jsx_runtime.jsx)(Initials, {
        children: (0, import_jsx_runtime.jsx)(Text, {
          as: "span",
          size: initialsSize,
          children: (0, import_jsx_runtime.jsx)("strong", {
            children: initials
          })
        })
      })
    })]
  });
});
var __freeze$A = Object.freeze;
var __defProp$B = Object.defineProperty;
var __template$A = (cooked, raw) => __freeze$A(__defProp$B(cooked, "raw", {
  value: __freeze$A(raw || cooked.slice())
}));
var _a$A;
function _responsiveAvatarCounterSizeStyle(props) {
  const {
    theme
  } = props;
  const {
    avatar,
    media
  } = theme.sanity;
  return _responsive(media, props.$size, (size3) => {
    const avatarSize = avatar.sizes[size3];
    if (!avatarSize)
      return EMPTY_RECORD;
    return {
      borderRadius: rem(avatarSize.size / 2),
      minWidth: rem(avatarSize.size),
      height: rem(avatarSize.size)
    };
  });
}
function _avatarCounterBaseStyle(props) {
  const {
    theme
  } = props;
  return Ae(_a$A || (_a$A = __template$A(["\n    align-items: center;\n    justify-content: center;\n    box-sizing: border-box;\n    user-select: none;\n    color: inherit;\n    color: var(--card-fg-color);\n    background: var(--card-bg-color);\n    box-shadow:\n      0 0 0 1px var(--card-bg-color),\n      inset 0 0 0 1.5px var(--card-hairline-hard-color);\n    padding: 0 ", ";\n\n    &:not([hidden]) {\n      display: flex;\n    }\n  "])), rem(theme.sanity.space[2]));
}
var Root$C = styled_components_browser_esm_default.div(_responsiveAvatarCounterSizeStyle, _avatarCounterBaseStyle);
var AvatarCounter = (0, import_react2.forwardRef)(function AvatarCounter2(props, ref) {
  const {
    count,
    size: sizeProp = 0
  } = props;
  const size3 = useArrayProp(sizeProp);
  const counterSize = (0, import_react2.useMemo)(() => size3.map((s) => s === 0 ? 0 : s + 1), [size3]);
  return (0, import_jsx_runtime.jsx)(Root$C, {
    $size: size3,
    "data-ui": "AvatarCounter",
    ref,
    children: (0, import_jsx_runtime.jsx)(Text, {
      as: "span",
      size: counterSize,
      children: (0, import_jsx_runtime.jsx)("strong", {
        children: count
      })
    })
  });
});
function childrenToElementArray(children) {
  const childrenArray = Array.isArray(children) ? children : [children];
  return childrenArray.filter((node) => (0, import_react_is.isElement)(node) || (0, import_react_is.isFragment)(node) || typeof node === "string");
}
var __freeze$z = Object.freeze;
var __defProp$A = Object.defineProperty;
var __template$z = (cooked, raw) => __freeze$z(__defProp$A(cooked, "raw", {
  value: __freeze$z(raw || cooked.slice())
}));
var _a$z;
var BASE_STYLES = Ae(_a$z || (_a$z = __template$z(["\n  white-space: nowrap;\n\n  & > div {\n    vertical-align: top;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  }\n"])));
function avatarStackStyle() {
  return BASE_STYLES;
}
function responsiveAvatarStackSizeStyle(props) {
  const {
    theme
  } = props;
  const {
    avatar,
    media
  } = theme.sanity;
  return _responsive(media, props.$size, (size3) => {
    const avatarSize = avatar.sizes[size3];
    if (!avatarSize)
      return EMPTY_RECORD;
    return {
      "& > div + div": {
        marginLeft: rem(avatarSize.distance)
      }
    };
  });
}
var Root$B = styled_components_browser_esm_default.div(responsiveAvatarStackSizeStyle, avatarStackStyle);
var AvatarStack = (0, import_react2.forwardRef)(function AvatarStack2(props, ref) {
  const {
    children: childrenProp,
    maxLength: maxLengthProp = 4,
    size: sizeProp = 0,
    ...restProps
  } = props;
  const children = childrenToElementArray(childrenProp).filter((child) => typeof child !== "string");
  const maxLength = Math.max(maxLengthProp, 0);
  const size3 = useArrayProp(sizeProp);
  const len = children.length;
  const visibleCount = maxLength - 1;
  const extraCount = len - visibleCount;
  const visibleChildren = extraCount > 1 ? children.slice(extraCount, len) : children;
  return (0, import_jsx_runtime.jsxs)(Root$B, {
    "data-ui": "AvatarStack",
    ...restProps,
    ref,
    $size: size3,
    children: [len === 0 && (0, import_jsx_runtime.jsx)("div", {
      children: (0, import_jsx_runtime.jsx)(AvatarCounter, {
        count: len
      })
    }), len !== 0 && extraCount > 1 && (0, import_jsx_runtime.jsx)("div", {
      children: (0, import_jsx_runtime.jsx)(AvatarCounter, {
        count: extraCount,
        size: size3
      })
    }), visibleChildren.map((child, childIndex) => (0, import_jsx_runtime.jsx)("div", {
      children: (0, import_react2.cloneElement)(child, {
        size: size3
      })
    }, String(childIndex)))]
  });
});
var Root$A = styled_components_browser_esm_default.div(boxStyle, flexItemStyle, responsiveBoxStyle, responsiveGridItemStyle, responsiveMarginStyle, responsivePaddingStyle);
var Box = (0, import_react2.forwardRef)(function Box2(props, ref) {
  const {
    as: asProp = "div",
    column,
    columnStart,
    columnEnd,
    display = "block",
    flex,
    height,
    margin = 0,
    marginX,
    marginY,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    overflow,
    padding = 0,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    row,
    rowStart,
    rowEnd,
    sizing,
    ...restProps
  } = props;
  return (0, import_jsx_runtime.jsx)(Root$A, {
    "data-as": typeof asProp === "string" ? asProp : void 0,
    "data-ui": "Box",
    ...restProps,
    $column: useArrayProp(column),
    $columnStart: useArrayProp(columnStart),
    $columnEnd: useArrayProp(columnEnd),
    $display: useArrayProp(display),
    $flex: useArrayProp(flex),
    $height: useArrayProp(height),
    $margin: useArrayProp(margin),
    $marginX: useArrayProp(marginX),
    $marginY: useArrayProp(marginY),
    $marginTop: useArrayProp(marginTop),
    $marginRight: useArrayProp(marginRight),
    $marginBottom: useArrayProp(marginBottom),
    $marginLeft: useArrayProp(marginLeft),
    $overflow: useArrayProp(overflow),
    $padding: useArrayProp(padding),
    $paddingX: useArrayProp(paddingX),
    $paddingY: useArrayProp(paddingY),
    $paddingTop: useArrayProp(paddingTop),
    $paddingRight: useArrayProp(paddingRight),
    $paddingBottom: useArrayProp(paddingBottom),
    $paddingLeft: useArrayProp(paddingLeft),
    $row: useArrayProp(row),
    $rowStart: useArrayProp(rowStart),
    $rowEnd: useArrayProp(rowEnd),
    $sizing: useArrayProp(sizing),
    as: asProp,
    ref,
    children: props.children
  });
});
var __freeze$y = Object.freeze;
var __defProp$z = Object.defineProperty;
var __template$y = (cooked, raw) => __freeze$y(__defProp$z(cooked, "raw", {
  value: __freeze$y(raw || cooked.slice())
}));
var _a$y;
var _b$k;
var _c$b;
function labelBaseStyle(props) {
  const {
    $accent,
    $muted,
    theme
  } = props;
  const {
    fonts
  } = theme.sanity;
  return Ae(_c$b || (_c$b = __template$y(["\n    text-transform: uppercase;\n\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), $accent && Ae(_a$y || (_a$y = __template$y(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && Ae(_b$k || (_b$k = __template$y(["\n      color: var(--card-muted-fg-color);\n    "]))), fonts.code.family);
}
var __freeze$x = Object.freeze;
var __defProp$y = Object.defineProperty;
var __template$x = (cooked, raw) => __freeze$x(__defProp$y(cooked, "raw", {
  value: __freeze$x(raw || cooked.slice())
}));
var _a$x;
var Root$z = styled_components_browser_esm_default.div(responsiveLabelFont, responsiveTextAlignStyle, labelBaseStyle);
var SpanWithTextOverflow$1 = styled_components_browser_esm_default.span(_a$x || (_a$x = __template$x(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  overflow: clip;\n"])));
var Label = (0, import_react2.forwardRef)(function Label2(props, ref) {
  const {
    accent,
    align,
    children: childrenProp,
    muted = false,
    size: size3 = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = (0, import_jsx_runtime.jsx)(SpanWithTextOverflow$1, {
      children
    });
  } else {
    children = (0, import_jsx_runtime.jsx)("span", {
      children
    });
  }
  return (0, import_jsx_runtime.jsx)(Root$z, {
    "data-ui": "Label",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align),
    $muted: muted,
    $size: useArrayProp(size3),
    $weight: weight,
    ref,
    children
  });
});
function badgeStyle(props) {
  const {
    $mode,
    $tone,
    theme
  } = props;
  const palette = theme.sanity.color[$mode === "outline" ? "muted" : "solid"];
  const color2 = palette[$tone] || palette.default;
  return {
    backgroundColor: color2.enabled.bg,
    color: color2.enabled.fg,
    boxShadow: "inset 0 0 0 1px ".concat(color2.enabled.border),
    cursor: "default",
    "&:not([hidden])": {
      display: "inline-block"
    }
  };
}
var Root$y = styled_components_browser_esm_default(Box)(responsiveRadiusStyle, badgeStyle);
var Badge = (0, import_react2.forwardRef)(function Badge2(props, ref) {
  const {
    children,
    fontSize: fontSize2,
    mode = "default",
    padding = 1,
    radius = 2,
    tone = "default",
    ...restProps
  } = props;
  return (0, import_jsx_runtime.jsx)(Root$y, {
    "data-ui": "Badge",
    ...restProps,
    $mode: mode,
    $tone: tone,
    $radius: useArrayProp(radius),
    padding: useArrayProp(padding),
    ref,
    children: (0, import_jsx_runtime.jsx)(Label, {
      size: fontSize2,
      children
    })
  });
});
var Root$x = styled_components_browser_esm_default(Box)(flexItemStyle, responsiveFlexStyle);
var Flex = (0, import_react2.forwardRef)(function Flex2(props, ref) {
  const {
    align,
    as,
    direction = "row",
    gap,
    justify,
    wrap,
    ...restProps
  } = props;
  return (
    // @ts-expect-error -- some dollar prefixed typings aren't inferred correctly https://github.com/styled-components/styled-components/issues/4062
    (0, import_jsx_runtime.jsx)(Root$x, {
      "data-ui": "Flex",
      ...restProps,
      $align: useArrayProp(align),
      $direction: useArrayProp(direction),
      $gap: useArrayProp(gap),
      $justify: useArrayProp(justify),
      $wrap: useArrayProp(wrap),
      forwardedAs: as,
      ref
    })
  );
});
var __freeze$w = Object.freeze;
var __defProp$x = Object.defineProperty;
var __template$w = (cooked, raw) => __freeze$w(__defProp$x(cooked, "raw", {
  value: __freeze$w(raw || cooked.slice())
}));
var _a$w;
var _b$j;
var rotate$1 = We(_a$w || (_a$w = __template$w(["\n  from {\n    transform: rotate(0deg);\n  }\n\n  to {\n    transform: rotate(360deg);\n  }\n"])));
var Root$w = styled_components_browser_esm_default(Text)(_b$j || (_b$j = __template$w(["\n  & > span > svg {\n    animation: ", " 500ms linear infinite;\n  }\n"])), rotate$1);
var Spinner = (0, import_react2.forwardRef)(function Spinner2(props, ref) {
  return (0, import_jsx_runtime.jsx)(Root$w, {
    "data-ui": "Spinner",
    ...props,
    ref,
    children: (0, import_jsx_runtime.jsx)(SpinnerIcon, {})
  });
});
function _colorVarsStyle(base, color2) {
  let checkered = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h;
  return {
    // Base
    // @todo: rename to "--base-"?
    "--card-shadow-outline-color": base.shadow.outline,
    "--card-shadow-umbra-color": base.shadow.umbra,
    "--card-shadow-penumbra-color": base.shadow.penumbra,
    "--card-shadow-ambient-color": base.shadow.ambient,
    "--card-focus-ring-color": base.focusRing,
    // Card
    "--card-bg-color": color2.bg,
    "--card-bg-image": checkered ? "repeating-conic-gradient(".concat(color2.bg, " 0% 25%, ").concat(color2.bg2 || color2.bg, " 0% 50%)") : void 0,
    "--card-fg-color": color2.fg,
    "--card-border-color": color2.border,
    "--card-muted-fg-color": (_a2 = color2.muted) == null ? void 0 : _a2.fg,
    "--card-accent-fg-color": (_b2 = color2.accent) == null ? void 0 : _b2.fg,
    "--card-link-fg-color": (_c2 = color2.link) == null ? void 0 : _c2.fg,
    "--card-code-bg-color": (_d2 = color2.code) == null ? void 0 : _d2.bg,
    "--card-code-fg-color": (_e2 = color2.code) == null ? void 0 : _e2.fg,
    "--card-skeleton-color-from": (_f2 = color2.skeleton) == null ? void 0 : _f2.from,
    "--card-skeleton-color-to": (_g2 = color2.skeleton) == null ? void 0 : _g2.to,
    // @todo: deprecate
    "--card-link-color": (_h = color2.link) == null ? void 0 : _h.fg,
    "--card-hairline-soft-color": color2.border,
    "--card-hairline-hard-color": color2.border
  };
}
var __freeze$v = Object.freeze;
var __defProp$w = Object.defineProperty;
var __template$v = (cooked, raw) => __freeze$v(__defProp$w(cooked, "raw", {
  value: __freeze$v(raw || cooked.slice())
}));
var _a$v;
function buttonBaseStyles() {
  return Ae(_a$v || (_a$v = __template$v(["\n    -webkit-font-smoothing: inherit;\n    appearance: none;\n    display: inline-flex;\n    align-items: center;\n    font: inherit;\n    border: 0;\n    outline: none;\n    user-select: none;\n    text-decoration: none;\n    border: 0;\n    box-sizing: border-box;\n    padding: 0;\n    margin: 0;\n    white-space: nowrap;\n    text-align: left;\n    position: relative;\n\n    & > span {\n      display: block;\n      flex: 1;\n      min-width: 0;\n      border-radius: inherit;\n    }\n\n    &::-moz-focus-inner {\n      border: 0;\n      padding: 0;\n    }\n  "])));
}
var buttonTheme = {
  border: {
    width: 1
  }
};
function buttonColorStyles(props) {
  var _a2, _b2;
  const {
    $mode,
    theme
  } = props;
  const {
    focusRing
  } = theme.sanity;
  const base = theme.sanity.color.base;
  const mode = theme.sanity.color.button[$mode] || theme.sanity.color.button.default;
  const color2 = mode[props.$tone] || mode.default;
  const border2 = {
    width: buttonTheme.border.width,
    color: "var(--card-border-color)"
  };
  return [_colorVarsStyle(base, color2.enabled), {
    backgroundColor: "var(--card-bg-color)",
    color: "var(--card-fg-color)",
    boxShadow: focusRingBorderStyle(border2),
    '&:disabled, &[data-disabled="true"]': _colorVarsStyle(base, color2.disabled),
    "&:not([data-disabled='true'])": {
      "&:focus": {
        boxShadow: focusRingStyle({
          base,
          border: border2,
          focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: focusRingBorderStyle(border2)
      },
      "@media (hover: hover)": {
        "&:hover": _colorVarsStyle(base, color2.hovered),
        "&:active": _colorVarsStyle(base, color2.pressed),
        "&[data-hovered]": _colorVarsStyle(base, color2.hovered)
      },
      "&[data-selected]": _colorVarsStyle(base, color2.pressed)
    }
  }, (_b2 = (_a2 = theme.sanity.styles) == null ? void 0 : _a2.button) == null ? void 0 : _b2.root].filter(Boolean);
}
var __freeze$u = Object.freeze;
var __defProp$v = Object.defineProperty;
var __template$u = (cooked, raw) => __freeze$u(__defProp$v(cooked, "raw", {
  value: __freeze$u(raw || cooked.slice())
}));
var _a$u;
var Root$v = styled_components_browser_esm_default.button(responsiveRadiusStyle, buttonBaseStyles, buttonColorStyles);
var LoadingBox = styled_components_browser_esm_default.div(_a$u || (_a$u = __template$u(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background-color: var(--card-bg-color);\n  border-radius: inherit;\n  z-index: 1;\n  box-shadow: inherit;\n"])));
var Button = (0, import_react2.forwardRef)(function Button2(props, ref) {
  const {
    children,
    disabled,
    fontSize: fontSize2,
    icon,
    iconRight,
    justify: justifyProp = "center",
    loading,
    mode = "default",
    padding: paddingProp = 3,
    paddingX: paddingXProp,
    paddingY: paddingYProp,
    paddingTop: paddingTopProp,
    paddingBottom: paddingBottomProp,
    paddingLeft: paddingLeftProp,
    paddingRight: paddingRightProp,
    radius: radiusProp = 2,
    selected,
    space: spaceProp = 3,
    text,
    textAlign,
    tone = "default",
    type = "button",
    ...restProps
  } = props;
  const justify = useArrayProp(justifyProp);
  const padding = useArrayProp(paddingProp);
  const paddingX = useArrayProp(paddingXProp);
  const paddingY = useArrayProp(paddingYProp);
  const paddingTop = useArrayProp(paddingTopProp);
  const paddingBottom = useArrayProp(paddingBottomProp);
  const paddingLeft = useArrayProp(paddingLeftProp);
  const paddingRight = useArrayProp(paddingRightProp);
  const radius = useArrayProp(radiusProp);
  const space = useArrayProp(spaceProp);
  const theme = useTheme();
  const boxProps = (0, import_react2.useMemo)(() => ({
    // flex: 1,
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight
  }), [padding, paddingX, paddingY, paddingTop, paddingBottom, paddingLeft, paddingRight]);
  return (0, import_jsx_runtime.jsxs)(Root$v, {
    "data-ui": "Button",
    ...restProps,
    $mode: mode,
    $radius: radius,
    $tone: tone,
    "data-disabled": Boolean(loading || disabled),
    "data-selected": selected ? "" : void 0,
    disabled: Boolean(loading || disabled),
    ref,
    type,
    children: [Boolean(loading) && (0, import_jsx_runtime.jsx)(LoadingBox, {
      children: (0, import_jsx_runtime.jsx)(Spinner, {})
    }), (icon || text || iconRight) && (0, import_jsx_runtime.jsx)(Box, {
      as: "span",
      ...boxProps,
      children: (0, import_jsx_runtime.jsxs)(Flex, {
        as: "span",
        justify,
        children: [icon && (0, import_jsx_runtime.jsxs)(Text, {
          size: fontSize2,
          children: [(0, import_react2.isValidElement)(icon) && icon, (0, import_react_is.isValidElementType)(icon) && (0, import_react2.createElement)(icon)]
        }), text && (0, import_jsx_runtime.jsx)(Box, {
          flex: iconRight ? 1 : void 0,
          marginLeft: icon ? space : void 0,
          marginRight: iconRight ? space : void 0,
          children: (0, import_jsx_runtime.jsx)(Text, {
            align: textAlign,
            size: fontSize2,
            textOverflow: "ellipsis",
            weight: theme.sanity.button.textWeight,
            children: text
          })
        }), iconRight && (0, import_jsx_runtime.jsxs)(Text, {
          size: fontSize2,
          children: [(0, import_react2.isValidElement)(iconRight) && iconRight, (0, import_react_is.isValidElementType)(iconRight) && (0, import_react2.createElement)(iconRight)]
        })]
      })
    }), children && (0, import_jsx_runtime.jsx)(Box, {
      as: "span",
      ...boxProps,
      children
    })]
  });
});
var __freeze$t = Object.freeze;
var __defProp$u = Object.defineProperty;
var __template$t = (cooked, raw) => __freeze$t(__defProp$u(cooked, "raw", {
  value: __freeze$t(raw || cooked.slice())
}));
var _a$t;
var _b$i;
var _c$a;
function cardStyle(props) {
  return [cardBaseStyle(props), cardColorStyle(props)];
}
function cardBaseStyle(props) {
  const {
    $checkered,
    theme
  } = props;
  const space = theme.sanity.space;
  return Ae(_b$i || (_b$i = __template$t(["\n    ", "\n\n    &[data-as='button'] {\n      -webkit-font-smoothing: inherit;\n      appearance: none;\n      outline: none;\n      font: inherit;\n      text-align: inherit;\n      border: 0;\n      width: -webkit-fill-available;\n      width: stretch;\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      outline: none;\n      text-decoration: none;\n    }\n\n    /* &:is(pre) */\n    &[data-as='pre'] {\n      font: inherit;\n    }\n  "])), $checkered && Ae(_a$t || (_a$t = __template$t(["\n      background-size: ", "px ", "px;\n      background-position: 50% 50%;\n      background-image: var(--card-bg-image);\n    "])), space[3], space[3]));
}
function cardColorStyle(props) {
  var _a2, _b2;
  const {
    $checkered,
    $focusRing,
    theme
  } = props;
  const {
    focusRing
  } = theme.sanity;
  const {
    base,
    card,
    dark
  } = theme.sanity.color;
  const border2 = {
    width: 0,
    color: "var(--card-border-color)"
  };
  return Ae(_c$a || (_c$a = __template$t(["\n    color-scheme: ", ";\n\n    ", "\n\n    background-color: var(--card-bg-color);\n    color: var(--card-fg-color);\n\n    /* &:is(button) */\n    &[data-as='button'] {\n      --card-focus-ring-box-shadow: none;\n\n      cursor: default;\n      box-shadow: var(--card-focus-ring-box-shadow);\n\n      &:disabled {\n        ", "\n      }\n\n      &:not(:disabled) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-pressed]):not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n\n        &:focus {\n          --card-focus-ring-box-shadow: ", ";\n        }\n\n        &:focus:not(:focus-visible) {\n          --card-focus-ring-box-shadow: ", ";\n        }\n      }\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      cursor: pointer;\n      box-shadow: var(--card-focus-ring-box-shadow);\n\n      &[data-disabled] {\n        ", "\n      }\n\n      &:not([data-disabled]) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-pressed]):not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n\n        &:focus {\n          --card-focus-ring-box-shadow: ", ";\n        }\n\n        &:focus:not(:focus-visible) {\n          --card-focus-ring-box-shadow: ", ";\n        }\n      }\n    }\n\n    ", "\n  "])), dark ? "dark" : "light", _colorVarsStyle(base, card.enabled, $checkered), _colorVarsStyle(base, card.disabled, $checkered), _colorVarsStyle(base, card.pressed, $checkered), _colorVarsStyle(base, card.selected, $checkered), _colorVarsStyle(base, card.hovered, $checkered), _colorVarsStyle(base, card.pressed, $checkered), $focusRing ? focusRingStyle({
    base,
    border: border2,
    focusRing
  }) : void 0, $focusRing ? focusRingBorderStyle(border2) : void 0, _colorVarsStyle(base, card.disabled, $checkered), _colorVarsStyle(base, card.pressed, $checkered), _colorVarsStyle(base, card.selected, $checkered), _colorVarsStyle(base, card.hovered, $checkered), _colorVarsStyle(base, card.pressed, $checkered), $focusRing ? focusRingStyle({
    base,
    border: border2,
    focusRing
  }) : void 0, $focusRing ? focusRingBorderStyle(border2) : void 0, (_b2 = (_a2 = theme.sanity.styles) == null ? void 0 : _a2.card) == null ? void 0 : _b2.root);
}
var Root$u = styled_components_browser_esm_default(Box)(responsiveBorderStyle, responsiveRadiusStyle, responsiveShadowStyle, cardStyle);
var Card = (0, import_react2.forwardRef)(function Card2(props, ref) {
  const {
    __unstable_checkered: checkered = false,
    __unstable_focusRing: focusRing = false,
    as: asProp,
    border: border2,
    borderTop: borderTop2,
    borderRight: borderRight2,
    borderBottom: borderBottom2,
    borderLeft: borderLeft2,
    pressed,
    radius = 0,
    scheme,
    selected,
    shadow,
    tone: toneProp = "default",
    ...restProps
  } = props;
  const as = (0, import_react_is.isValidElementType)(asProp) ? asProp : "div";
  const rootTheme = useRootTheme();
  const tone = toneProp === "inherit" ? rootTheme.tone : toneProp;
  return (0, import_jsx_runtime.jsx)(ThemeColorProvider, {
    scheme,
    tone,
    children: (0, import_jsx_runtime.jsx)(Root$u, {
      "data-as": typeof as === "string" ? as : void 0,
      "data-scheme": rootTheme.scheme,
      "data-ui": "Card",
      "data-tone": tone,
      ...restProps,
      $border: useArrayProp(border2),
      $borderTop: useArrayProp(borderTop2),
      $borderRight: useArrayProp(borderRight2),
      $borderBottom: useArrayProp(borderBottom2),
      $borderLeft: useArrayProp(borderLeft2),
      $checkered: checkered,
      $focusRing: focusRing,
      $radius: useArrayProp(radius),
      $shadow: useArrayProp(shadow),
      $tone: tone,
      "data-checkered": checkered ? "" : void 0,
      "data-pressed": pressed ? "" : void 0,
      "data-selected": selected ? "" : void 0,
      forwardedAs: as,
      ref,
      selected
    })
  });
});
var __freeze$s = Object.freeze;
var __defProp$t = Object.defineProperty;
var __template$s = (cooked, raw) => __freeze$s(__defProp$t(cooked, "raw", {
  value: __freeze$s(raw || cooked.slice())
}));
var _a$s;
var _b$h;
function checkboxBaseStyles() {
  return Ae(_a$s || (_a$s = __template$s(["\n    position: relative;\n    display: inline-block;\n  "])));
}
function inputElementStyles(props) {
  const {
    theme
  } = props;
  const color2 = theme.sanity.color.input;
  const {
    focusRing,
    input,
    radius
  } = theme.sanity;
  return Ae(_b$h || (_b$h = __template$s(["\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    outline: none;\n    opacity: 0;\n    z-index: 1;\n    padding: 0;\n    margin: 0;\n\n    & + span {\n      position: relative;\n      display: block;\n      height: ", ";\n      width: ", ";\n      box-sizing: border-box;\n      box-shadow: ", ";\n      border-radius: ", ";\n      line-height: 1;\n      background-color: ", ";\n\n      & > svg {\n        display: block;\n        position: absolute;\n        opacity: 0;\n        height: 100%;\n        width: 100%;\n\n        & > path {\n          vector-effect: non-scaling-stroke;\n          stroke-width: 2 !important;\n        }\n      }\n    }\n\n    &:not(:disabled):focus + span {\n      box-shadow: ", ";\n    }\n\n    &:not(:disabled):focus:not(:focus-visible) + span {\n      box-shadow: ", ";\n    }\n\n    &:checked + span > svg:first-child {\n      opacity: 1;\n    }\n\n    &[data-read-only] + span {\n      background-color: ", ";\n      box-shadow: ", ";\n      color: ", ";\n    }\n\n    &:not([data-read-only]):disabled + span {\n      background-color: ", ";\n      box-shadow: ", ";\n      color: ", ";\n    }\n\n    &:indeterminate + span > svg:last-child {\n      opacity: 1;\n    }\n  "])), rem(input.checkbox.size), rem(input.checkbox.size), focusRingBorderStyle({
    color: color2.default.enabled.border,
    width: input.border.width
  }), rem(radius[2]), color2.default.enabled.bg, focusRingStyle({
    border: {
      width: input.border.width,
      color: color2.default.enabled.border
    },
    focusRing
  }), focusRingBorderStyle({
    color: color2.default.enabled.border,
    width: input.border.width
  }), color2.default.readOnly.bg, focusRingBorderStyle({
    width: input.border.width,
    color: color2.default.readOnly.border
  }), color2.default.readOnly.fg, color2.default.disabled.bg, focusRingBorderStyle({
    width: input.border.width,
    color: color2.default.disabled.border
  }), color2.default.disabled.fg);
}
var Root$t = styled_components_browser_esm_default.div(checkboxBaseStyles);
var Input$5 = styled_components_browser_esm_default.input(inputElementStyles);
var Checkbox = (0, import_react2.forwardRef)(function Checkbox2(props, forwardedRef) {
  const {
    checked,
    className,
    disabled,
    indeterminate,
    customValidity,
    readOnly,
    style,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  (0, import_react2.useEffect)(() => {
    if (ref.current) {
      ref.current.indeterminate = indeterminate || false;
    }
  }, [indeterminate, ref]);
  return (0, import_jsx_runtime.jsxs)(Root$t, {
    className,
    "data-ui": "Checkbox",
    style,
    children: [(0, import_jsx_runtime.jsx)(Input$5, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      ...restProps,
      checked,
      disabled: disabled || readOnly,
      type: "checkbox",
      readOnly,
      ref
    }), (0, import_jsx_runtime.jsxs)("span", {
      children: [(0, import_jsx_runtime.jsx)(CheckmarkIcon, {}), (0, import_jsx_runtime.jsx)(RemoveIcon, {})]
    })]
  });
});
var __freeze$r = Object.freeze;
var __defProp$s = Object.defineProperty;
var __template$r = (cooked, raw) => __freeze$r(__defProp$s(cooked, "raw", {
  value: __freeze$r(raw || cooked.slice())
}));
var _a$r;
function codeSyntaxHighlightingStyle(_ref20) {
  let {
    theme
  } = _ref20;
  const color2 = theme.sanity.color.syntax;
  return {
    "&.atrule": {
      color: color2.atrule
    },
    "&.attr-name": {
      color: color2.attrName
    },
    "&.attr-value": {
      color: color2.attrValue
    },
    "&.attribute": {
      color: color2.attribute
    },
    "&.boolean": {
      color: color2.boolean
    },
    "&.builtin": {
      color: color2.builtin
    },
    "&.cdata": {
      color: color2.cdata
    },
    "&.char": {
      color: color2.char
    },
    "&.class": {
      color: color2.class
    },
    "&.class-name": {
      color: color2.className
    },
    "&.comment": {
      color: color2.comment
    },
    "&.constant": {
      color: color2.constant
    },
    "&.deleted": {
      color: color2.deleted
    },
    "&.doctype": {
      color: color2.doctype
    },
    "&.entity": {
      color: color2.entity
    },
    "&.function": {
      color: color2.function
    },
    "&.hexcode": {
      color: color2.hexcode
    },
    "&.id": {
      color: color2.id
    },
    "&.important": {
      color: color2.important
    },
    "&.inserted": {
      color: color2.inserted
    },
    "&.keyword": {
      color: color2.keyword
    },
    "&.number": {
      color: color2.number
    },
    "&.operator": {
      color: color2.operator
    },
    "&.prolog": {
      color: color2.prolog
    },
    "&.property": {
      color: color2.property
    },
    "&.pseudo-class": {
      color: color2.pseudoClass
    },
    "&.pseudo-element": {
      color: color2.pseudoElement
    },
    "&.punctuation": {
      color: color2.punctuation
    },
    "&.regex": {
      color: color2.regex
    },
    "&.selector": {
      color: color2.selector
    },
    "&.string": {
      color: color2.string
    },
    "&.symbol": {
      color: color2.symbol
    },
    "&.tag": {
      color: color2.tag
    },
    "&.unit": {
      color: color2.unit
    },
    "&.url": {
      color: color2.url
    },
    "&.variable": {
      color: color2.variable
    }
  };
}
function codeBaseStyle() {
  return Ae(_a$r || (_a$r = __template$r(["\n    color: var(--card-code-fg-color);\n\n    & code {\n      font-family: inherit;\n\n      &.refractor .token {\n        ", "\n      }\n    }\n\n    & a {\n      color: inherit;\n      text-decoration: underline;\n      border-radius: 1px;\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), codeSyntaxHighlightingStyle);
}
var Root$s = styled_components_browser_esm_default.pre(codeBaseStyle, responsiveCodeFontStyle);
var Code = (0, import_react2.forwardRef)(function Code2(props, ref) {
  const {
    children,
    language: languageProp,
    size: size3 = 2,
    weight,
    ...restProps
  } = props;
  const language = typeof languageProp === "string" ? languageProp : void 0;
  const registered = language ? import_react_refractor.default.hasLanguage(language) : false;
  return (0, import_jsx_runtime.jsxs)(Root$s, {
    "data-ui": "Code",
    ...restProps,
    $size: useArrayProp(size3),
    $weight: weight,
    ref,
    children: [!(language && registered) && (0, import_jsx_runtime.jsx)("code", {
      children
    }), language && registered && (0, import_jsx_runtime.jsx)(import_react_refractor.default, {
      inline: true,
      language,
      value: String(children)
    })]
  });
});
var BASE_STYLE$1 = {
  width: "100%",
  margin: "0 auto"
};
function containerBaseStyle() {
  return BASE_STYLE$1;
}
function responsiveContainerWidthStyle(props) {
  const {
    theme
  } = props;
  const {
    container,
    media
  } = theme.sanity;
  return _responsive(media, props.$width, (val) => ({
    maxWidth: val === "auto" ? "none" : rem(container[val])
  }));
}
var Root$r = styled_components_browser_esm_default(Box)(containerBaseStyle, responsiveContainerWidthStyle);
var Container = (0, import_react2.forwardRef)(function Container2(props, ref) {
  const {
    as,
    width = 2,
    ...restProps
  } = props;
  return (0, import_jsx_runtime.jsx)(Root$r, {
    "data-ui": "Container",
    ...restProps,
    $width: useArrayProp(width),
    forwardedAs: as,
    ref
  });
});
var Root$q = styled_components_browser_esm_default(Box)(responsiveGridStyle);
var Grid = (0, import_react2.forwardRef)(function Grid2(props, ref) {
  const {
    as,
    autoRows,
    autoCols,
    autoFlow,
    columns,
    gap,
    gapX,
    gapY,
    rows,
    children,
    ...restProps
  } = props;
  return (0, import_jsx_runtime.jsx)(Root$q, {
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Grid",
    ...restProps,
    $autoRows: useArrayProp(autoRows),
    $autoCols: useArrayProp(autoCols),
    $autoFlow: useArrayProp(autoFlow),
    $columns: useArrayProp(columns),
    $gap: useArrayProp(gap),
    $gapX: useArrayProp(gapX),
    $gapY: useArrayProp(gapY),
    $rows: useArrayProp(rows),
    forwardedAs: as,
    ref,
    children
  });
});
var __freeze$q = Object.freeze;
var __defProp$r = Object.defineProperty;
var __template$q = (cooked, raw) => __freeze$q(__defProp$r(cooked, "raw", {
  value: __freeze$q(raw || cooked.slice())
}));
var _a$q;
var _b$g;
var _c$9;
function headingBaseStyle(props) {
  const {
    $accent,
    $muted,
    theme
  } = props;
  return Ae(_c$9 || (_c$9 = __template$q(["\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n      color: var(--card-link-color);\n      outline: none;\n\n      @media (hover: hover) {\n        &:hover {\n          text-decoration: underline;\n        }\n      }\n\n      &:focus {\n        box-shadow:\n          0 0 0 1px var(--card-bg-color),\n          0 0 0 3px var(--card-focus-ring-color);\n      }\n\n      &:focus:not(:focus-visible) {\n        box-shadow: none;\n      }\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), $accent && Ae(_a$q || (_a$q = __template$q(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && Ae(_b$g || (_b$g = __template$q(["\n      color: var(--card-muted-fg-color);\n    "]))), theme.sanity.fonts.code.family);
}
var __freeze$p = Object.freeze;
var __defProp$q = Object.defineProperty;
var __template$p = (cooked, raw) => __freeze$p(__defProp$q(cooked, "raw", {
  value: __freeze$p(raw || cooked.slice())
}));
var _a$p;
var Root$p = styled_components_browser_esm_default.div(headingBaseStyle, responsiveTextAlignStyle, responsiveHeadingFont);
var SpanWithTextOverflow = styled_components_browser_esm_default.span(_a$p || (_a$p = __template$p(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  overflow: clip;\n"])));
var Heading = (0, import_react2.forwardRef)(function Heading2(props, ref) {
  const {
    accent = false,
    align,
    children: childrenProp,
    muted = false,
    size: size3 = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = (0, import_jsx_runtime.jsx)(SpanWithTextOverflow, {
      children
    });
  }
  return (0, import_jsx_runtime.jsx)(Root$p, {
    "data-ui": "Heading",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align),
    $muted: muted,
    $size: useArrayProp(size3),
    $weight: weight,
    ref,
    children: (0, import_jsx_runtime.jsx)("span", {
      children
    })
  });
});
function inlineBaseStyle() {
  return {
    lineHeight: 0,
    "&&:not([hidden])": {
      display: "block"
    },
    "& > div": {
      display: "inline-block",
      verticalAlign: "middle"
    }
  };
}
function inlineSpaceStyle(props) {
  const {
    theme
  } = props;
  return _responsive(theme.sanity.media, props.$space, (spaceIndex) => {
    const space = rem(theme.sanity.space[spaceIndex]);
    return {
      margin: "-".concat(space, " 0 0 -").concat(space),
      "& > div": {
        padding: "".concat(space, " 0 0 ").concat(space)
      }
    };
  });
}
var Root$o = styled_components_browser_esm_default(Box)(inlineBaseStyle, inlineSpaceStyle);
var Inline = (0, import_react2.forwardRef)(function Inline2(props, ref) {
  const {
    as,
    children: childrenProp,
    space,
    ...restProps
  } = props;
  const children = (0, import_react2.useMemo)(() => childrenToElementArray(childrenProp).filter(Boolean).map((child, idx) => (0, import_jsx_runtime.jsx)("div", {
    children: child
  }, idx)), [childrenProp]);
  return (0, import_jsx_runtime.jsx)(Root$o, {
    "data-ui": "Inline",
    ...restProps,
    $space: useArrayProp(space),
    forwardedAs: as,
    ref,
    children
  });
});
var __freeze$o = Object.freeze;
var __defProp$p = Object.defineProperty;
var __template$o = (cooked, raw) => __freeze$o(__defProp$p(cooked, "raw", {
  value: __freeze$o(raw || cooked.slice())
}));
var _a$o;
function kbdStyle() {
  return Ae(_a$o || (_a$o = __template$o(["\n    background: var(--card-bg-color);\n    font: inherit;\n    box-shadow: inset 0 0 0 1px var(--card-hairline-hard-color);\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
var Root$n = styled_components_browser_esm_default.kbd(responsiveRadiusStyle, kbdStyle);
var KBD = (0, import_react2.forwardRef)(function KBD2(props, ref) {
  const {
    children,
    fontSize: fontSize2 = 1,
    padding = 1,
    radius = 2,
    ...restProps
  } = props;
  return (0, import_jsx_runtime.jsx)(Root$n, {
    "data-ui": "KBD",
    ...restProps,
    $radius: useArrayProp(radius),
    ref,
    children: (0, import_jsx_runtime.jsx)(Box, {
      as: "span",
      padding,
      children: (0, import_jsx_runtime.jsx)(Code, {
        as: "span",
        muted: true,
        size: fontSize2,
        children
      })
    })
  });
});
var key$7 = Symbol.for("@sanity/ui/context/boundaryElement");
globalScope[key$7] = globalScope[key$7] || (0, import_react2.createContext)(null);
var BoundaryElementContext = globalScope[key$7];
var DEFAULT_VALUE = {
  version: 0,
  element: null
};
function useBoundaryElement() {
  const value = (0, import_react2.useContext)(BoundaryElementContext);
  if (value && (!isRecord(value) || value.version !== 0)) {
    throw new Error("useBoundaryElement(): the context value is not compatible");
  }
  return value || DEFAULT_VALUE;
}
function findMaxBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1) {
    const bp = media[i];
    if (bp > width) {
      ret.push(i);
    }
  }
  return ret;
}
function findMinBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1) {
    const bp = media[i];
    if (bp <= width) {
      ret.push(i);
    }
  }
  return ret;
}
var ElementQuery = (0, import_react2.forwardRef)(function ElementQuery2(props, ref) {
  const theme = useTheme();
  const {
    children,
    media = theme.sanity.media,
    ...restProps
  } = props;
  const forwardedRef = useForwardedRef(ref);
  const [element, setElement] = (0, import_react2.useState)(null);
  const elementSize = useElementSize(element);
  const width = (0, import_react2.useMemo)(() => {
    var _a2;
    return (_a2 = elementSize == null ? void 0 : elementSize.border.width) != null ? _a2 : window.innerWidth;
  }, [elementSize]);
  const max = (0, import_react2.useMemo)(() => findMaxBreakpoints(media, width), [media, width]);
  const min = (0, import_react2.useMemo)(() => findMinBreakpoints(media, width), [media, width]);
  const setRef = (0, import_react2.useCallback)((el) => {
    forwardedRef.current = el;
    setElement(el);
  }, [forwardedRef]);
  return (0, import_jsx_runtime.jsx)("div", {
    "data-ui": "ElementQuery",
    ...restProps,
    "data-eq-max": max.length ? max.join(" ") : void 0,
    "data-eq-min": min.length ? min.join(" ") : void 0,
    ref: setRef,
    children
  });
});
function getLayerContext(contextValue) {
  if (!isRecord(contextValue) || contextValue.version !== 0) {
    throw new Error("the context value is not compatible");
  }
  if (!contextValue) {
    throw new Error("components using `useLayer()` should be wrapped in a <LayerProvider>.");
  }
  if (contextValue.version === 0) {
    return contextValue;
  }
  throw new Error("could not get layer context");
}
var key$6 = Symbol.for("@sanity/ui/context/layer");
globalScope[key$6] = globalScope[key$6] || (0, import_react2.createContext)(null);
var LayerContext = globalScope[key$6];
function useLayer() {
  const value = (0, import_react2.useContext)(LayerContext);
  if (!value) {
    throw new Error("useLayer(): missing context value");
  }
  try {
    return getLayerContext(value);
  } catch (err) {
    if (err instanceof Error) {
      throw new Error("useLayer(): ".concat(err.message));
    } else {
      throw new Error("useLayer(): ".concat(err));
    }
  }
}
function _raf(fn) {
  const frameId = requestAnimationFrame(fn);
  return () => {
    cancelAnimationFrame(frameId);
  };
}
function _isEnterToClickElement(element) {
  return isHTMLAnchorElement(element) || isHTMLButtonElement(element);
}
function isHTMLElement(node) {
  return node instanceof Node && node.nodeType === Node.ELEMENT_NODE;
}
function isHTMLAnchorElement(element) {
  return isHTMLElement(element) && element.nodeName === "A";
}
function isHTMLInputElement(element) {
  return isHTMLElement(element) && element.nodeName === "INPUT";
}
function isHTMLButtonElement(element) {
  return isHTMLElement(element) && element.nodeName === "BUTTON";
}
function isHTMLSelectElement(element) {
  return isHTMLElement(element) && element.nodeName === "SELECT";
}
function isHTMLTextAreaElement(element) {
  return isHTMLElement(element) && element.nodeName === "TEXTAREA";
}
function containsOrEqualsElement(element, node) {
  return element.contains(node) || element === node;
}
function _hasFocus(element) {
  return Boolean(document.activeElement) && element.contains(document.activeElement);
}
function isFocusable(element) {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
    return true;
  }
  if (isHTMLAnchorElement(element)) {
    return Boolean(element.href) && element.rel !== "ignore";
  }
  if (isHTMLInputElement(element)) {
    return element.type !== "hidden" && element.type !== "file" && !element.disabled;
  }
  if (isHTMLButtonElement(element) || isHTMLSelectElement(element) || isHTMLTextAreaElement(element)) {
    return !element.disabled;
  }
  return false;
}
function attemptFocus(element) {
  if (!isFocusable(element)) {
    return false;
  }
  try {
    element.focus();
  } catch (_) {
  }
  return document.activeElement === element;
}
function focusFirstDescendant(element) {
  for (let i = 0; i < element.childNodes.length; i++) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusFirstDescendant(child))) {
      return true;
    }
  }
  return false;
}
function focusLastDescendant(element) {
  for (let i = element.childNodes.length - 1; i >= 0; i--) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusLastDescendant(child))) {
      return true;
    }
  }
  return false;
}
function _isScrollable(el) {
  if (!(el instanceof Element))
    return false;
  const style = window.getComputedStyle(el);
  return style.overflowX.includes("auto") || style.overflowX.includes("scroll") || style.overflowY.includes("auto") || style.overflowY.includes("scroll");
}
function LayerProvider(props) {
  var _a2;
  const {
    children,
    zOffset: zOffsetProp = 0
  } = props;
  const parentContextValue = (0, import_react2.useContext)(LayerContext);
  const parent = parentContextValue && getLayerContext(parentContextValue);
  const parentRegisterChild = parent == null ? void 0 : parent.registerChild;
  const parentLevel = (_a2 = parent == null ? void 0 : parent.level) != null ? _a2 : 0;
  const level = parentLevel + 1;
  const zOffset = useArrayProp(zOffsetProp);
  const maxMediaIndex = zOffset.length - 1;
  const mediaIndex = Math.min(useMediaIndex(), maxMediaIndex);
  const zIndex = parent ? parent.zIndex + zOffset[mediaIndex] : zOffset[mediaIndex];
  const [, setChildLayers] = (0, import_react2.useState)({});
  const [size3, setSize] = (0, import_react2.useState)(0);
  const isTopLayer = size3 === 0;
  const registerChild = (0, import_react2.useCallback)((childLevel) => {
    const parentDispose = parentRegisterChild == null ? void 0 : parentRegisterChild(childLevel);
    if (childLevel !== void 0) {
      setChildLayers((state) => {
        var _a22;
        const prevLen = (_a22 = state[childLevel]) != null ? _a22 : 0;
        const nextState = {
          ...state,
          [childLevel]: prevLen + 1
        };
        setSize(Object.keys(nextState).length);
        return nextState;
      });
    } else {
      setSize((v) => v + 1);
    }
    return () => {
      if (childLevel !== void 0) {
        setChildLayers((state) => {
          const nextState = {
            ...state
          };
          if (nextState[childLevel] === 1) {
            delete nextState[childLevel];
            setSize(Object.keys(nextState).length);
          } else {
            nextState[childLevel] -= 1;
          }
          return nextState;
        });
      } else {
        setSize((v) => v - 1);
      }
      parentDispose == null ? void 0 : parentDispose();
    };
  }, [parentRegisterChild]);
  (0, import_react2.useEffect)(() => parentRegisterChild == null ? void 0 : parentRegisterChild(level), [level, parentRegisterChild]);
  const value = (0, import_react2.useMemo)(() => ({
    version: 0,
    isTopLayer,
    level,
    registerChild,
    size: size3,
    zIndex
  }), [isTopLayer, level, registerChild, size3, zIndex]);
  return (0, import_jsx_runtime.jsx)(LayerContext.Provider, {
    value,
    children
  });
}
var Root$m = styled_components_browser_esm_default.div({
  position: "relative"
});
var LayerChildren = (0, import_react2.forwardRef)(function LayerChildren2(props, ref) {
  const {
    children,
    onActivate,
    onFocus,
    style = EMPTY_RECORD,
    ...restProps
  } = props;
  const {
    zIndex,
    isTopLayer
  } = useLayer();
  const lastFocusedRef = (0, import_react2.useRef)(null);
  const forwardedRef = useForwardedRef(ref);
  const isTopLayerRef = (0, import_react2.useRef)(isTopLayer);
  (0, import_react2.useEffect)(() => {
    const becameTopLayer = isTopLayerRef.current !== isTopLayer && isTopLayer;
    if (becameTopLayer) {
      onActivate == null ? void 0 : onActivate({
        activeElement: lastFocusedRef.current
      });
    }
    isTopLayerRef.current = isTopLayer;
  }, [isTopLayer, onActivate]);
  const handleFocus = (0, import_react2.useCallback)((event) => {
    onFocus == null ? void 0 : onFocus(event);
    const rootElement = forwardedRef.current;
    const target = document.activeElement;
    if (!isTopLayer || !rootElement || !target)
      return;
    if (isHTMLElement(target) && containsOrEqualsElement(rootElement, target)) {
      lastFocusedRef.current = target;
    }
  }, [forwardedRef, isTopLayer, onFocus]);
  return (0, import_jsx_runtime.jsx)(Root$m, {
    ...restProps,
    "data-ui": "Layer",
    onFocus: handleFocus,
    ref: forwardedRef,
    style: {
      ...style,
      zIndex
    },
    children
  });
});
var Layer = (0, import_react2.forwardRef)(function Layer2(props, ref) {
  const {
    children,
    zOffset = 1,
    ...restProps
  } = props;
  return (0, import_jsx_runtime.jsx)(LayerProvider, {
    zOffset,
    children: (0, import_jsx_runtime.jsx)(LayerChildren, {
      ...restProps,
      ref,
      children
    })
  });
});
var key$5 = Symbol.for("@sanity/ui/context/portal");
var elementKey = Symbol.for("@sanity/ui/context/portal/element");
globalScope[elementKey] = null;
var defaultContextValue = {
  version: 0,
  boundaryElement: null,
  get element() {
    if (typeof document === "undefined") {
      return null;
    }
    if (globalScope[elementKey]) {
      return globalScope[elementKey];
    }
    globalScope[elementKey] = document.createElement("div");
    globalScope[elementKey].setAttribute("data-portal", "");
    document.body.appendChild(globalScope[elementKey]);
    return globalScope[elementKey];
  }
};
globalScope[key$5] = globalScope[key$5] || (0, import_react2.createContext)(defaultContextValue);
var PortalContext = globalScope[key$5];
function usePortal() {
  const value = (0, import_react2.useContext)(PortalContext);
  if (!value) {
    throw new Error("usePortal(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("usePortal(): the context value is not compatible");
  }
  return value;
}
function Portal(props) {
  var _a2;
  const {
    children,
    __unstable_name: name
  } = props;
  const portal = usePortal();
  const portalElement = (name ? portal.elements && portal.elements[name] : portal.element) || ((_a2 = portal.elements) == null ? void 0 : _a2.default);
  if (!portalElement) {
    return null;
  }
  return (0, import_react_dom2.createPortal)(children, portalElement);
}
var __freeze$n = Object.freeze;
var __defProp$n = Object.defineProperty;
var __template$n = (cooked, raw) => __freeze$n(__defProp$n(cooked, "raw", {
  value: __freeze$n(raw || cooked.slice())
}));
var _a$n;
var Root$l = styled_components_browser_esm_default.div(_a$n || (_a$n = __template$n(["\n  display: block;\n  width: 0;\n  height: 0;\n  position: absolute;\n  overflow: hidden;\n  overflow: clip;\n"])));
var SrOnly = (0, import_react2.forwardRef)(function SrOnly2(props, ref) {
  const {
    as,
    children
  } = props;
  return (0, import_jsx_runtime.jsx)(Root$l, {
    "aria-hidden": true,
    as,
    "data-ui": "SrOnly",
    ref,
    children
  });
});
var __freeze$m = Object.freeze;
var __defProp$m = Object.defineProperty;
var __template$m = (cooked, raw) => __freeze$m(__defProp$m(cooked, "raw", {
  value: __freeze$m(raw || cooked.slice())
}));
var _a$m;
var _b$f;
var Root$k = styled_components_browser_esm_default.div(_a$m || (_a$m = __template$m(["\n  position: relative;\n"])));
var ItemWrapper = styled_components_browser_esm_default.div(_b$f || (_b$f = __template$m(["\n  position: absolute;\n  left: 0;\n  right: 0;\n"])));
var VirtualList = (0, import_react2.forwardRef)(function VirtualList2(props, ref) {
  const {
    as = "div",
    gap = 0,
    getItemKey,
    items = [],
    onChange,
    renderItem,
    ...restProps
  } = props;
  const {
    space
  } = useTheme().sanity;
  const forwardedRef = useForwardedRef(ref);
  const wrapperRef = (0, import_react2.useRef)(null);
  const [scrollTop, setScrollTop] = (0, import_react2.useState)(0);
  const [scrollHeight, setScrollHeight] = (0, import_react2.useState)(0);
  const [itemHeight, setItemHeight] = (0, import_react2.useState)(-1);
  (0, import_react2.useEffect)(() => {
    if (!wrapperRef.current)
      return;
    const firstElement = wrapperRef.current.firstChild;
    if (firstElement instanceof HTMLElement) {
      setItemHeight(firstElement.offsetHeight);
    }
  }, [renderItem]);
  (0, import_react2.useEffect)(() => {
    if (!forwardedRef.current)
      return;
    let _scrollEl = forwardedRef.current.parentNode;
    while (_scrollEl && !_isScrollable(_scrollEl)) {
      _scrollEl = _scrollEl.parentNode;
    }
    if (_scrollEl) {
      const scrollEl = _scrollEl;
      if (!(scrollEl instanceof HTMLElement))
        return;
      const handleScroll2 = () => {
        setScrollTop(scrollEl.scrollTop);
      };
      scrollEl.addEventListener("scroll", handleScroll2, {
        passive: true
      });
      const ro = new _ResizeObserver((entries) => {
        setScrollHeight(entries[0].contentRect.height);
      });
      ro.observe(scrollEl);
      handleScroll2();
      return () => {
        scrollEl.removeEventListener("scroll", handleScroll2);
        ro.unobserve(scrollEl);
        ro.disconnect();
      };
    }
    const handleScroll = () => {
      setScrollTop(window.scrollY);
    };
    const handleResize = () => {
      setScrollHeight(window.innerHeight);
    };
    window.addEventListener("scroll", handleScroll, {
      passive: true
    });
    window.addEventListener("resize", handleResize);
    setScrollHeight(window.innerHeight);
    handleScroll();
    return () => {
      window.removeEventListener("scroll", handleScroll);
      window.removeEventListener("resize", handleResize);
    };
  }, [forwardedRef]);
  const len = items.length;
  const height = itemHeight ? len * (itemHeight + space[gap]) - space[gap] : 0;
  const fromIndex = height ? Math.max(Math.floor(scrollTop / height * len) - 2, 0) : 0;
  const toIndex = height ? Math.ceil((scrollTop + scrollHeight) / height * len) + 1 : 0;
  (0, import_react2.useEffect)(() => {
    if (!onChange)
      return;
    onChange({
      fromIndex,
      gap: space[gap],
      itemHeight,
      scrollHeight,
      scrollTop,
      toIndex
    });
  }, [fromIndex, gap, itemHeight, onChange, scrollHeight, scrollTop, space, toIndex]);
  const children = (0, import_react2.useMemo)(() => {
    if (!renderItem || items.length === 0)
      return null;
    if (itemHeight === -1) {
      return [(0, import_jsx_runtime.jsx)(ItemWrapper, {
        children: renderItem(items[0])
      }, 0)];
    }
    return items.slice(fromIndex, toIndex).map((item, _itemIndex) => {
      const itemIndex = fromIndex + _itemIndex;
      const node = renderItem(item);
      const key2 = getItemKey ? getItemKey(item, itemIndex) : itemIndex;
      return (0, import_jsx_runtime.jsx)(ItemWrapper, {
        style: {
          top: itemIndex * (itemHeight + space[gap])
        },
        children: node
      }, key2);
    });
  }, [fromIndex, gap, getItemKey, itemHeight, items, renderItem, space, toIndex]);
  const wrapperStyle = (0, import_react2.useMemo)(() => ({
    height
  }), [height]);
  return (0, import_jsx_runtime.jsx)(Root$k, {
    as,
    "data-ui": "VirtualList",
    ...restProps,
    ref: forwardedRef,
    children: (0, import_jsx_runtime.jsx)("div", {
      ref: wrapperRef,
      style: wrapperStyle,
      children
    })
  });
});
var DEFAULT_POPOVER_DISTANCE = 4;
var DEFAULT_POPOVER_PADDING = 4;
var DEFAULT_POPOVER_ARROW_WIDTH = 27;
var DEFAULT_POPOVER_ARROW_HEIGHT = 11;
var DEFAULT_POPOVER_MARGINS = [0, 0, 0, 0];
var DEFAULT_FALLBACK_PLACEMENTS$1 = {
  top: ["bottom", "left", "right"],
  "top-start": ["bottom-start", "left-start", "right-start"],
  "top-end": ["bottom-end", "left-end", "right-end"],
  bottom: ["top", "left", "right"],
  "bottom-start": ["top-start", "left-start", "right-start"],
  "bottom-end": ["top-end", "left-end", "right-end"],
  left: ["right", "top", "bottom"],
  "left-start": ["right-start", "top-start", "bottom-start"],
  "left-end": ["right-end", "top-end", "bottom-end"],
  right: ["left", "top", "bottom"],
  "right-start": ["left-start", "top-start", "bottom-start"],
  "right-end": ["left-end", "top-end", "bottom-end"]
};
function size2(options) {
  const {
    apply,
    margins,
    padding = 0
  } = options;
  return {
    name: "@sanity/ui/size",
    async fn(args) {
      const {
        elements,
        placement,
        platform: platform2,
        rects
      } = args;
      const {
        floating,
        reference
      } = rects;
      const overflow = await detectOverflow(args, {
        altBoundary: true,
        boundary: options.boundaryElement || void 0,
        elementContext: "floating",
        padding,
        rootBoundary: "viewport"
      });
      let maxWidth = Infinity;
      let maxHeight = Infinity;
      const floatingW = floating.width;
      const floatingH = floating.height;
      if (placement.includes("top")) {
        maxWidth = floatingW - (overflow.left + overflow.right);
        maxHeight = floatingH - overflow.top;
      }
      if (placement.includes("right")) {
        maxWidth = floatingW - overflow.right;
        maxHeight = floatingH - (overflow.top + overflow.bottom);
      }
      if (placement.includes("bottom")) {
        maxWidth = floatingW - (overflow.left + overflow.right);
        maxHeight = floatingH - overflow.bottom;
      }
      if (placement.includes("left")) {
        maxWidth = floatingW - overflow.left;
        maxHeight = floatingH - (overflow.top + overflow.bottom);
      }
      apply({
        availableWidth: maxWidth - margins[1] - margins[3],
        availableHeight: maxHeight - margins[0] - margins[2],
        elements,
        referenceWidth: reference.width - margins[1] - margins[3]
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      const targetH = nextDimensions.height;
      const targetW = nextDimensions.width;
      if (floatingW !== targetW || floatingH !== targetH) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
}
function calcCurrentWidth(params) {
  const {
    mediaIndex,
    theme,
    width
  } = params;
  const w = width[mediaIndex];
  const currentWidth = w === void 0 ? width[width.length - 1] : w;
  return typeof currentWidth === "number" ? theme.sanity.container[currentWidth] : void 0;
}
function calcMaxWidth(params) {
  const {
    boundaryWidth,
    currentWidth
  } = params;
  if (currentWidth === void 0 && boundaryWidth === void 0) {
    return void 0;
  }
  return Math.min(currentWidth != null ? currentWidth : Infinity, (boundaryWidth || Infinity) - DEFAULT_POPOVER_PADDING * 2);
}
var __freeze$l = Object.freeze;
var __defProp$l = Object.defineProperty;
var __template$l = (cooked, raw) => __freeze$l(__defProp$l(cooked, "raw", {
  value: __freeze$l(raw || cooked.slice())
}));
var _a$l;
var _b$e;
var _c$8;
var Root$j = styled_components_browser_esm_default.div(_a$l || (_a$l = __template$l(["\n  position: absolute;\n  pointer-events: none;\n  width: ", "px;\n  height: ", "px;\n  fill: none;\n\n  :empty + & {\n    display: none;\n  }\n\n  & > svg {\n    display: block;\n    transform-origin: ", "px ", "px;\n  }\n\n  [data-placement^='top'] > & {\n    bottom: -", "px;\n  }\n\n  [data-placement^='right'] > & {\n    left: -", "px;\n\n    & > svg {\n      transform: rotate(90deg);\n    }\n  }\n\n  [data-placement^='left'] > & {\n    right: -", "px;\n\n    & > svg {\n      transform: rotate(-90deg);\n    }\n  }\n\n  [data-placement^='bottom'] > & {\n    top: -", "px;\n\n    & > svg {\n      transform: rotate(180deg);\n    }\n  }\n"])), DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH / 2, DEFAULT_POPOVER_ARROW_WIDTH / 2, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH);
var BorderPath = styled_components_browser_esm_default.path(_b$e || (_b$e = __template$l(["\n  fill: var(--card-shadow-outline-color);\n"])));
var ShapePath = styled_components_browser_esm_default.path(_c$8 || (_c$8 = __template$l(["\n  fill: var(--card-bg-color);\n"])));
var PopoverArrow = (0, import_react2.forwardRef)(function PopoverArrow2(props, ref) {
  return (0, import_jsx_runtime.jsx)(Root$j, {
    "data-ui": "Popover__arrow",
    ...props,
    ref,
    children: (0, import_jsx_runtime.jsxs)("svg", {
      width: DEFAULT_POPOVER_ARROW_WIDTH,
      height: DEFAULT_POPOVER_ARROW_HEIGHT,
      viewBox: "0 0 27 11",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [(0, import_jsx_runtime.jsx)(BorderPath, {
        d: "M1.18708 1C3.29803 1.0011 5.29585 1.95479 6.62414 3.59561L11.1683 9.20895C12.369 10.6922 14.631 10.6922 15.8317 9.20894L20.3759 3.59561C21.7042 1.95478 23.702 1.0011 25.8129 1H21.9436C21.0533 1.49255 20.2545 2.15618 19.5986 2.96641L15.0545 8.57975C14.254 9.56855 12.746 9.56855 11.9455 8.57975L7.40139 2.96642C6.74548 2.15618 5.94673 1.49255 5.05643 1H1.18708Z"
      }), (0, import_jsx_runtime.jsx)(ShapePath, {
        d: "M1.18342 0C3.59749 0 5.88246 1.0901 7.40138 2.96642L11.9455 8.57975C12.746 9.56855 14.254 9.56855 15.0545 8.57975L19.5986 2.96641C21.1175 1.0901 23.4025 0 25.8166 0H27H0H1.18342Z"
      })]
    })
  });
});
var Root$i = styled_components_browser_esm_default(Card)({
  "&:not([hidden])": {
    display: "flex"
  },
  flexDirection: "column",
  width: "max-content",
  minWidth: "min-content"
});
var PopoverCard = (0, import_react2.memo)((0, import_react2.forwardRef)(function PopoverCard2(props, ref) {
  const {
    __unstable_margins: marginsProp,
    arrow: arrow3,
    arrowRef,
    arrowX,
    arrowY,
    children,
    padding,
    placement,
    overflow,
    radius,
    scheme,
    shadow,
    strategy,
    style,
    tone,
    width,
    x: xProp,
    y: yProp,
    ...restProps
  } = props;
  const {
    zIndex
  } = useLayer();
  const margins = (0, import_react2.useMemo)(() => marginsProp || DEFAULT_POPOVER_MARGINS, [marginsProp]);
  const x = (xProp != null ? xProp : 0) + margins[3];
  const y = (yProp != null ? yProp : 0) + margins[0];
  const rootStyle2 = (0, import_react2.useMemo)(() => ({
    position: strategy,
    top: y,
    left: x,
    width,
    zIndex,
    ...style
  }), [strategy, style, width, x, y, zIndex]);
  const staticSide = placement && FLOATING_STATIC_SIDES[placement.split("-")[0]];
  const arrowStyle = (0, import_react2.useMemo)(() => {
    const style2 = {
      left: arrowX !== null ? arrowX : void 0,
      top: arrowY !== null ? arrowY : void 0,
      right: void 0,
      bottom: void 0
    };
    if (staticSide)
      style2[staticSide] = 0 - DEFAULT_POPOVER_ARROW_WIDTH;
    return style2;
  }, [arrowX, arrowY, staticSide]);
  return (0, import_jsx_runtime.jsxs)(Root$i, {
    "data-ui": "Popover",
    ...restProps,
    "data-placement": placement,
    radius,
    ref,
    scheme,
    shadow,
    sizing: "border",
    style: rootStyle2,
    tone,
    children: [(0, import_jsx_runtime.jsx)(Flex, {
      "data-ui": "Popover__wrapper",
      direction: "column",
      flex: 1,
      overflow,
      children: (0, import_jsx_runtime.jsx)(Flex, {
        direction: "column",
        flex: 1,
        padding,
        children
      })
    }), arrow3 && (0, import_jsx_runtime.jsx)(PopoverArrow, {
      ref: arrowRef,
      style: arrowStyle
    })]
  });
}));
PopoverCard.displayName = "PopoverCard";
var Popover = (0, import_react2.memo)((0, import_react2.forwardRef)(function Popover2(props, ref) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h, _i;
  const theme = useTheme();
  const boundaryElementContext = useBoundaryElement();
  const {
    __unstable_margins: margins = DEFAULT_POPOVER_MARGINS,
    arrow: arrowProp = true,
    boundaryElement = boundaryElementContext.element,
    children: childProp,
    constrainSize = false,
    content,
    disabled,
    fallbackPlacements = (_b2 = props.fallbackPlacements) != null ? _b2 : DEFAULT_FALLBACK_PLACEMENTS$1[(_a2 = props.placement) != null ? _a2 : "bottom"],
    matchReferenceWidth,
    floatingBoundary = (_c2 = props.boundaryElement) != null ? _c2 : boundaryElementContext.element,
    open,
    overflow = "hidden",
    padding: paddingProp,
    placement: placementProp = "bottom",
    portal,
    preventOverflow = true,
    radius: radiusProp = 3,
    referenceBoundary = (_d2 = props.boundaryElement) != null ? _d2 : boundaryElementContext.element,
    referenceElement,
    scheme,
    shadow: shadowProp = 3,
    tone = "inherit",
    width: widthProp = "auto",
    zOffset: zOffsetProp = (_e2 = theme.sanity.layer) == null ? void 0 : _e2.popover.zOffset,
    updateRef,
    ...restProps
  } = props;
  const boundarySize = (_f2 = useElementSize(boundaryElement)) == null ? void 0 : _f2.border;
  const padding = useArrayProp(paddingProp);
  const radius = useArrayProp(radiusProp);
  const shadow = useArrayProp(shadowProp);
  const widthArrayProp = useArrayProp(widthProp);
  const zOffset = useArrayProp(zOffsetProp);
  const forwardedRef = useForwardedRef(ref);
  const arrowRef = (0, import_react2.useRef)(null);
  const rootBoundary = "viewport";
  const mediaIndex = useMediaIndex();
  const boundaryWidth = constrainSize || preventOverflow ? boundarySize == null ? void 0 : boundarySize.width : void 0;
  const width = calcCurrentWidth({
    mediaIndex,
    theme,
    width: widthArrayProp
  });
  const widthRef = (0, import_react2.useRef)(width);
  (0, import_react2.useEffect)(() => {
    widthRef.current = width;
  }, [width]);
  const maxWidth = calcMaxWidth({
    boundaryWidth,
    currentWidth: width
  });
  const maxWidthRef = (0, import_react2.useRef)(maxWidth);
  (0, import_react2.useEffect)(() => {
    maxWidthRef.current = maxWidth;
  }, [maxWidth]);
  const referenceWidthRef = (0, import_react2.useRef)();
  (0, import_react2.useEffect)(() => {
    const floatingElement = forwardedRef.current;
    if (!open || !floatingElement)
      return;
    const referenceWidth = referenceWidthRef.current;
    if (matchReferenceWidth) {
      if (referenceWidth !== void 0) {
        floatingElement.style.width = "".concat(referenceWidth, "px");
      }
    } else if (width !== void 0) {
      floatingElement.style.width = "".concat(width, "px");
    }
    if (typeof maxWidth === "number") {
      floatingElement.style.maxWidth = "".concat(maxWidth, "px");
    }
  }, [width, forwardedRef, matchReferenceWidth, maxWidth, open]);
  const middleware = (0, import_react2.useMemo)(() => {
    const ret = [];
    if (constrainSize || preventOverflow) {
      ret.push(flip({
        boundary: floatingBoundary || void 0,
        fallbackPlacements,
        padding: DEFAULT_POPOVER_PADDING,
        rootBoundary
      }));
    }
    ret.push(offset({
      mainAxis: arrowProp ? DEFAULT_POPOVER_DISTANCE : 0
    }));
    if (constrainSize || matchReferenceWidth) {
      ret.push(size2({
        apply(_ref21) {
          let {
            availableWidth,
            availableHeight,
            elements,
            referenceWidth
          } = _ref21;
          referenceWidthRef.current = referenceWidth;
          const _currentWidth = widthRef.current;
          const _maxWidth = maxWidthRef.current;
          if (matchReferenceWidth) {
            elements.floating.style.width = "".concat(referenceWidth, "px");
          } else if (_currentWidth !== void 0) {
            elements.floating.style.width = "".concat(_currentWidth, "px");
          }
          if (constrainSize) {
            elements.floating.style.maxWidth = "".concat(Math.min(availableWidth, _maxWidth != null ? _maxWidth : Infinity), "px");
            elements.floating.style.maxHeight = "".concat(availableHeight, "px");
          }
        },
        boundaryElement: floatingBoundary || void 0,
        constrainSize,
        margins,
        matchReferenceWidth,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    if (preventOverflow) {
      ret.push(shift({
        boundary: floatingBoundary || void 0,
        rootBoundary,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    if (arrowProp) {
      ret.push(arrow2({
        element: arrowRef,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    ret.push(hide({
      boundary: referenceBoundary || void 0,
      padding: DEFAULT_POPOVER_PADDING,
      strategy: "referenceHidden"
    }));
    return ret;
  }, [arrowProp, constrainSize, fallbackPlacements, floatingBoundary, margins, matchReferenceWidth, preventOverflow, referenceBoundary]);
  const {
    x,
    y,
    middlewareData,
    placement,
    refs,
    strategy,
    update
  } = useFloating({
    middleware,
    placement: placementProp,
    whileElementsMounted: autoUpdate
  });
  const referenceHidden = (_g2 = middlewareData.hide) == null ? void 0 : _g2.referenceHidden;
  const arrowX = (_h = middlewareData.arrow) == null ? void 0 : _h.x;
  const arrowY = (_i = middlewareData.arrow) == null ? void 0 : _i.y;
  const setArrow = (0, import_react2.useCallback)((arrowEl) => {
    arrowRef.current = arrowEl;
  }, []);
  const setFloating = (0, import_react2.useCallback)((node) => {
    forwardedRef.current = node;
    refs.setFloating(node);
  }, [forwardedRef, refs]);
  const setReference = (0, import_react2.useCallback)((node) => {
    refs.setReference(node);
    const childRef = childProp == null ? void 0 : childProp.ref;
    if (typeof childRef === "function") {
      childRef(node);
    } else if (childRef) {
      childRef.current = node;
    }
  }, [childProp, refs]);
  const child = (0, import_react2.useMemo)(() => {
    if (!childProp || referenceElement)
      return null;
    return (0, import_react2.cloneElement)(childProp, {
      ref: setReference
    });
  }, [childProp, referenceElement, setReference]);
  (0, import_react2.useEffect)(() => {
    if (updateRef) {
      if (typeof updateRef === "function") {
        updateRef(update);
      } else if (updateRef) {
        updateRef.current = update;
      }
    }
  }, [update, updateRef]);
  (0, import_react2.useEffect)(() => {
    refs.setReference(referenceElement || null);
  }, [referenceElement, refs]);
  if (disabled) {
    return childProp || (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
  }
  const popover = (0, import_jsx_runtime.jsx)(LayerProvider, {
    zOffset,
    children: (0, import_jsx_runtime.jsx)(PopoverCard, {
      ...restProps,
      __unstable_margins: margins,
      arrow: arrowProp,
      arrowRef: setArrow,
      arrowX,
      arrowY,
      hidden: referenceHidden,
      overflow,
      padding,
      placement,
      radius,
      ref: setFloating,
      scheme,
      shadow,
      strategy,
      tone,
      width: matchReferenceWidth ? referenceWidthRef.current : width,
      x,
      y,
      children: content
    })
  });
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [open && (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
      children: portal ? (0, import_jsx_runtime.jsx)(Portal, {
        __unstable_name: typeof portal === "string" ? portal : void 0,
        children: popover
      }) : popover
    }), child]
  });
}));
Popover.displayName = "Popover";
var __freeze$k = Object.freeze;
var __defProp$k = Object.defineProperty;
var __template$k = (cooked, raw) => __freeze$k(__defProp$k(cooked, "raw", {
  value: __freeze$k(raw || cooked.slice())
}));
var _a$k;
var _b$d;
function radioBaseStyle() {
  return Ae(_a$k || (_a$k = __template$k(["\n    position: relative;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n\n    &[data-read-only] {\n      outline: 1px solid red;\n    }\n  "])));
}
function inputElementStyle(props) {
  const {
    theme
  } = props;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color2 = theme.sanity.color.input;
  const dist = (input.radio.size - input.radio.markSize) / 2;
  return Ae(_b$d || (_b$d = __template$k(["\n    appearance: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    opacity: 0;\n    height: 100%;\n    width: 100%;\n    outline: none;\n    z-index: 1;\n    padding: 0;\n    margin: 0;\n    border-radius: ", ";\n    border: none;\n\n    /* enabled */\n    & + span {\n      display: block;\n      position: relative;\n      height: ", ";\n      width: ", ";\n      border-radius: ", ";\n      background: ", ";\n      box-shadow: ", ";\n\n      &::after {\n        content: '';\n        position: absolute;\n        top: ", ";\n        left: ", ";\n        height: ", ";\n        width: ", ";\n        border-radius: ", ";\n        background: ", ";\n        opacity: 0;\n      }\n    }\n\n    /* focused */\n    &:not(:disabled):focus + span {\n      box-shadow: ", ";\n    }\n\n    &:not(:disabled):focus:not(:focus-visible) + span {\n      box-shadow: ", ";\n    }\n\n    &:checked + span::after {\n      opacity: 1;\n    }\n\n    /* read only */\n    &[data-read-only] + span {\n      box-shadow: 0 0 0 1px ", ";\n      background: ", ";\n\n      &::after {\n        background: ", ";\n      }\n    }\n\n    /* disabled */\n    &:not([data-read-only]):disabled + span {\n      box-shadow: 0 0 0 1px ", ";\n      background: ", ";\n\n      &::after {\n        background: ", ";\n      }\n    }\n  "])), rem(input.radio.size / 2), rem(input.radio.size), rem(input.radio.size), rem(input.radio.size / 2), color2.default.enabled.bg, focusRingBorderStyle({
    color: color2.default.enabled.border,
    width: input.border.width
  }), rem(dist), rem(dist), rem(input.radio.markSize), rem(input.radio.markSize), rem(input.radio.markSize / 2), color2.default.enabled.fg, focusRingStyle({
    border: {
      width: input.border.width,
      color: color2.default.enabled.border
    },
    focusRing
  }), focusRingBorderStyle({
    color: color2.default.enabled.border,
    width: input.border.width
  }), color2.default.readOnly.border, color2.default.readOnly.bg, color2.default.readOnly.fg, color2.default.disabled.border, color2.default.disabled.bg, color2.default.disabled.fg);
}
var Root$h = styled_components_browser_esm_default.div(radioBaseStyle);
var Input$4 = styled_components_browser_esm_default.input(inputElementStyle);
var Radio = (0, import_react2.forwardRef)(function Radio2(props, forwardedRef) {
  const {
    className,
    disabled,
    style,
    customValidity,
    readOnly,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  return (0, import_jsx_runtime.jsxs)(Root$h, {
    className,
    "data-ui": "Radio",
    style,
    children: [(0, import_jsx_runtime.jsx)(Input$4, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      ...restProps,
      disabled: disabled || readOnly,
      readOnly,
      ref,
      type: "radio"
    }), (0, import_jsx_runtime.jsx)("span", {})]
  });
});
var __freeze$j = Object.freeze;
var __defProp$j = Object.defineProperty;
var __template$j = (cooked, raw) => __freeze$j(__defProp$j(cooked, "raw", {
  value: __freeze$j(raw || cooked.slice())
}));
var _a$j;
var _b$c;
var _c$7;
var _d$5;
function rootStyle() {
  return Ae(_a$j || (_a$j = __template$j(["\n    position: relative;\n    width: -webkit-fill-available;\n    width: stretch;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
function inputBaseStyle(props) {
  const {
    theme
  } = props;
  const font = theme.sanity.fonts.text;
  return Ae(_b$c || (_b$c = __template$j(["\n    -webkit-font-smoothing: antialiased;\n    appearance: none;\n    border: 0;\n    font-family: ", ";\n    color: inherit;\n    width: 100%;\n    outline: none;\n    margin: 0;\n\n    &:disabled {\n      opacity: 1;\n    }\n  "])), font.family);
}
function inputColorStyle(props) {
  const {
    theme
  } = props;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color2 = theme.sanity.color.input;
  return Ae(_c$7 || (_c$7 = __template$j(["\n    /* enabled */\n    background-color: ", ";\n    color: ", ";\n    box-shadow: ", ";\n\n    /* hovered */\n    @media (hover: hover) {\n      &:not(:disabled):hover {\n        background-color: ", ";\n        color: ", ";\n        box-shadow: ", ";\n      }\n    }\n\n    /* focused */\n    &:not(:disabled):focus {\n      box-shadow: ", ";\n    }\n\n    /* read-only */\n    &[data-read-only] {\n      background-color: ", ";\n      color: ", ";\n      box-shadow: ", ";\n    }\n\n    /* disabled */\n    &:not([data-read-only]):disabled {\n      background-color: ", ";\n      color: ", ";\n      box-shadow: ", ";\n    }\n  "])), color2.default.enabled.bg, color2.default.enabled.fg, focusRingBorderStyle({
    color: color2.default.enabled.border,
    width: input.border.width
  }), color2.default.hovered.bg, color2.default.hovered.fg, focusRingBorderStyle({
    color: color2.default.hovered.border,
    width: input.border.width
  }), focusRingStyle({
    border: {
      width: input.border.width,
      color: color2.default.enabled.border
    },
    focusRing
  }), color2.default.readOnly.bg, color2.default.readOnly.fg, focusRingBorderStyle({
    color: color2.default.readOnly.border,
    width: input.border.width
  }), color2.default.disabled.bg, color2.default.disabled.fg, focusRingBorderStyle({
    color: color2.default.disabled.border,
    width: input.border.width
  }));
}
function textSize(size3) {
  return {
    fontSize: rem(size3.fontSize),
    lineHeight: rem(size3.lineHeight)
  };
}
function inputTextSizeStyle(props) {
  const {
    theme,
    $fontSize
  } = props;
  const {
    sizes
  } = theme.sanity.fonts.text;
  return _responsive(theme.sanity.media, $fontSize, (sizeIndex) => textSize(sizes[sizeIndex] || sizes[2]));
}
function inputStyle() {
  return [responsiveRadiusStyle, inputBaseStyle, inputColorStyle, inputTextSizeStyle, responsiveInputPaddingIconRightStyle];
}
function iconBoxStyle(props) {
  const {
    theme
  } = props;
  const color2 = theme.sanity.color.input;
  return Ae(_d$5 || (_d$5 = __template$j(["\n    pointer-events: none;\n    position: absolute;\n    top: 0;\n    right: 0;\n\n    /* enabled */\n    --card-fg-color: ", ";\n\n    /* hover */\n    @media (hover: hover) {\n      select:not(disabled):not(:read-only):hover + && {\n        --card-fg-color: ", ";\n      }\n    }\n\n    /* disabled */\n    select:disabled + && {\n      --card-fg-color: ", ";\n    }\n\n    /* read-only */\n    select[data-read-only] + && {\n      --card-fg-color: ", ";\n    }\n  "])), color2.default.enabled.fg, color2.default.hovered.fg, color2.default.disabled.fg, color2.default.readOnly.fg);
}
var selectStyle = {
  root: rootStyle,
  input: inputStyle,
  iconBox: iconBoxStyle
};
var Root$g = styled_components_browser_esm_default.div(selectStyle.root);
var Input$3 = styled_components_browser_esm_default.select(selectStyle.input);
var IconBox = styled_components_browser_esm_default(Box)(selectStyle.iconBox);
var Select = (0, import_react2.forwardRef)(function Select2(props, forwardedRef) {
  const {
    children,
    customValidity,
    disabled,
    fontSize: fontSize2 = 2,
    padding = 3,
    radius = 1,
    readOnly,
    space = 3,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  return (0, import_jsx_runtime.jsxs)(Root$g, {
    "data-ui": "Select",
    children: [(0, import_jsx_runtime.jsx)(Input$3, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      "data-ui": "Select",
      ...restProps,
      $fontSize: useArrayProp(fontSize2),
      $padding: useArrayProp(padding),
      $radius: useArrayProp(radius),
      $space: useArrayProp(space),
      disabled: disabled || readOnly,
      ref,
      children
    }), (0, import_jsx_runtime.jsx)(IconBox, {
      padding,
      children: (0, import_jsx_runtime.jsx)(Text, {
        size: fontSize2,
        children: (0, import_jsx_runtime.jsx)(SelectIcon, {})
      })
    })]
  });
});
var BASE_STYLE = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  },
  gridTemplateColumns: "minmax(0, 1fr)",
  gridAutoRows: "min-content"
};
function stackBaseStyle() {
  return BASE_STYLE;
}
function responsiveStackSpaceStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$space, (spaceIndex) => ({
    gridGap: rem(space[spaceIndex])
  }));
}
var Root$f = styled_components_browser_esm_default(Box)(stackBaseStyle, responsiveStackSpaceStyle);
var Stack = (0, import_react2.forwardRef)(function Stack2(props, ref) {
  const {
    as,
    space,
    ...restProps
  } = props;
  return (0, import_jsx_runtime.jsx)(Root$f, {
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Stack",
    ...restProps,
    $space: useArrayProp(space),
    forwardedAs: as,
    ref
  });
});
var __freeze$i = Object.freeze;
var __defProp$i = Object.defineProperty;
var __template$i = (cooked, raw) => __freeze$i(__defProp$i(cooked, "raw", {
  value: __freeze$i(raw || cooked.slice())
}));
var _a$i;
var _b$b;
var _c$6;
var _d$4;
var _e$2;
var _f$2;
var _g;
function switchBaseStyles() {
  return Ae(_a$i || (_a$i = __template$i(["\n    position: relative;\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
function switchInputStyles() {
  return Ae(_b$b || (_b$b = __template$i(["\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    opacity: 0;\n    height: 100%;\n    width: 100%;\n    outline: none;\n    padding: 0;\n    margin: 0;\n\n    /* Place the input element above the representation element */\n    z-index: 1;\n  "])));
}
function switchRepresentationStyles(props) {
  const {
    theme
  } = props;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color2 = theme.sanity.color.button.default;
  return Ae(_c$6 || (_c$6 = __template$i(["\n    --switch-bg-color: ", ";\n    --switch-fg-color: ", ";\n    --switch-box-shadow: none;\n\n    &:not([hidden]) {\n      display: block;\n    }\n    position: relative;\n    width: ", ";\n    height: ", ";\n    border-radius: ", ";\n\n    /* Make sure its not possible to interact with the wrapper element */\n    pointer-events: none;\n\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      z-index: 1;\n      box-shadow: var(--switch-box-shadow);\n      border-radius: inherit;\n    }\n\n    /* Focus styles */\n    input:focus + && {\n      --switch-box-shadow: ", ";\n    }\n\n    input:focus:not(:focus-visible) + && {\n      --switch-box-shadow: none;\n    }\n\n    input:checked + && {\n      --switch-bg-color: ", ";\n      --switch-fg-color: ", ";\n    }\n\n    @media (hover: hover) {\n      input:not(:disabled):hover + && {\n        --switch-bg-color: ", ";\n        --switch-fg-color: ", ";\n      }\n\n      input:not(:disabled):checked:hover + && {\n        --switch-bg-color: ", ";\n        --switch-fg-color: ", ";\n      }\n    }\n\n    input:not([data-read-only]):disabled + && {\n      --switch-bg-color: ", ";\n      --switch-fg-color: ", ";\n    }\n  "])), color2.default.enabled.bg, color2.default.enabled.fg, rem(input.switch.width), rem(input.switch.height), rem(input.switch.height / 2), focusRingStyle({
    focusRing
  }), color2.positive.enabled.bg, color2.positive.enabled.fg, color2.default.hovered.bg, color2.default.hovered.fg, color2.positive.hovered.bg, color2.positive.hovered.fg, color2.default.disabled.bg, color2.default.disabled.fg);
}
function switchTrackStyles(props) {
  const {
    theme
  } = props;
  const {
    input
  } = theme.sanity;
  return Ae(_d$4 || (_d$4 = __template$i(["\n    &:not([hidden]) {\n      display: block;\n    }\n    background-color: var(--switch-bg-color);\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: ", ";\n    height: ", ";\n    border-radius: ", ";\n  "])), rem(input.switch.width), rem(input.switch.height), rem(input.switch.height / 2));
}
function switchThumbStyles(props) {
  const {
    $indeterminate,
    theme
  } = props;
  const {
    input
  } = theme.sanity;
  const trackWidth = input.switch.width;
  const trackHeight = input.switch.height;
  const trackPadding = input.switch.padding;
  const size3 = trackHeight - input.switch.padding * 2;
  const checkedOffset = trackWidth - trackPadding * 2 - size3;
  const indeterminateOffset = trackWidth / 2 - size3 / 2 - trackPadding;
  const checked = $indeterminate !== true && props.$checked === true;
  return Ae(_g || (_g = __template$i(["\n    &:not([hidden]) {\n      display: block;\n    }\n    position: absolute;\n    left: ", ";\n    top: ", ";\n    height: ", ";\n    width: ", ";\n    border-radius: ", ";\n    transition-property: transform;\n    transition-duration: ", "ms;\n    transition-timing-function: ", ";\n    background: var(--switch-fg-color);\n    transform: translate3d(0, 0, 0);\n\n    ", "\n\n    ", "\n  "])), rem(trackPadding), rem(trackPadding), rem(size3), rem(size3), rem(size3 / 2), input.switch.transitionDurationMs, input.switch.transitionTimingFunction, checked && Ae(_e$2 || (_e$2 = __template$i(["\n      transform: translate3d(", "px, 0, 0);\n    "])), checkedOffset), $indeterminate && Ae(_f$2 || (_f$2 = __template$i(["\n      transform: translate3d(", "px, 0, 0);\n    "])), indeterminateOffset));
}
var Root$e = styled_components_browser_esm_default.span(switchBaseStyles);
var Input$2 = styled_components_browser_esm_default.input(switchInputStyles);
var Representation = styled_components_browser_esm_default.span(switchRepresentationStyles);
var Track = styled_components_browser_esm_default.span(switchTrackStyles);
var Thumb = styled_components_browser_esm_default.span(switchThumbStyles);
var Switch = (0, import_react2.forwardRef)(function Switch2(props, forwardedRef) {
  const {
    checked,
    className,
    disabled,
    indeterminate,
    readOnly,
    style,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  (0, import_react2.useEffect)(() => {
    if (ref.current) {
      ref.current.indeterminate = indeterminate || false;
    }
  }, [indeterminate, ref]);
  return (0, import_jsx_runtime.jsxs)(Root$e, {
    className,
    "data-ui": "Switch",
    style,
    children: [(0, import_jsx_runtime.jsx)(Input$2, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      ...restProps,
      checked: indeterminate !== true && checked,
      disabled: disabled || readOnly,
      type: "checkbox",
      ref
    }), (0, import_jsx_runtime.jsxs)(Representation, {
      "aria-hidden": true,
      "data-name": "representation",
      children: [(0, import_jsx_runtime.jsx)(Track, {}), (0, import_jsx_runtime.jsx)(Thumb, {
        $checked: checked,
        $indeterminate: indeterminate
      })]
    })]
  });
});
var __freeze$h = Object.freeze;
var __defProp$h = Object.defineProperty;
var __template$h = (cooked, raw) => __freeze$h(__defProp$h(cooked, "raw", {
  value: __freeze$h(raw || cooked.slice())
}));
var _a$h;
var Root$d = styled_components_browser_esm_default.span(textInputRootStyle);
var InputRoot$1 = styled_components_browser_esm_default.span(_a$h || (_a$h = __template$h(["\n  flex: 1;\n  min-width: 0;\n  display: block;\n  position: relative;\n"])));
var Input$1 = styled_components_browser_esm_default.textarea(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle);
var Presentation$1 = styled_components_browser_esm_default.div(responsiveRadiusStyle, textInputRepresentationStyle);
var TextArea = (0, import_react2.forwardRef)(function TextArea2(props, forwardedRef) {
  const {
    border: border2 = true,
    customValidity,
    disabled = false,
    fontSize: fontSize2 = 2,
    padding = 3,
    radius = 1,
    weight,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  const rootTheme = useRootTheme();
  useCustomValidity(ref, customValidity);
  return (0, import_jsx_runtime.jsx)(Root$d, {
    "data-ui": "TextArea",
    children: (0, import_jsx_runtime.jsxs)(InputRoot$1, {
      children: [(0, import_jsx_runtime.jsx)(Input$1, {
        "data-as": "textarea",
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone,
        ...restProps,
        $fontSize: useArrayProp(fontSize2),
        $padding: useArrayProp(padding),
        $scheme: rootTheme.scheme,
        $space: useArrayProp(0),
        $tone: rootTheme.tone,
        $weight: weight,
        disabled,
        ref
      }), (0, import_jsx_runtime.jsx)(Presentation$1, {
        $radius: useArrayProp(radius),
        $scheme: rootTheme.scheme,
        $tone: rootTheme.tone,
        "data-border": border2 ? "" : void 0,
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone
      })]
    })
  });
});
var __freeze$g = Object.freeze;
var __defProp$g = Object.defineProperty;
var __template$g = (cooked, raw) => __freeze$g(__defProp$g(cooked, "raw", {
  value: __freeze$g(raw || cooked.slice())
}));
var _a$g;
var _b$a;
var _c$5;
var _d$3;
var _e$1;
var _f$1;
var CLEAR_BUTTON_BOX_STYLE = {
  zIndex: 2
};
var Root$c = styled_components_browser_esm_default(Card).attrs({
  forwardedAs: "span"
})(textInputRootStyle);
var InputRoot = styled_components_browser_esm_default.span(_a$g || (_a$g = __template$g(["\n  flex: 1;\n  min-width: 0;\n  display: block;\n  position: relative;\n"])));
var Prefix = styled_components_browser_esm_default(Card).attrs({
  forwardedAs: "span"
})(_b$a || (_b$a = __template$g(["\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n\n  & > span {\n    display: block;\n    margin: -1px;\n  }\n"])));
var Suffix = styled_components_browser_esm_default(Card).attrs({
  forwardedAs: "span"
})(_c$5 || (_c$5 = __template$g(["\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n\n  & > span {\n    display: block;\n    margin: -1px;\n  }\n"])));
var Input = styled_components_browser_esm_default.input(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle);
var Presentation = styled_components_browser_esm_default.span(responsiveRadiusStyle, textInputRepresentationStyle);
var LeftBox = styled_components_browser_esm_default(Box)(_d$3 || (_d$3 = __template$g(["\n  position: absolute;\n  top: 0;\n  left: 0;\n"])));
var RightBox = styled_components_browser_esm_default(Box)(_e$1 || (_e$1 = __template$g(["\n  position: absolute;\n  top: 0;\n  right: 0;\n"])));
var RightCard = styled_components_browser_esm_default(Card)(_f$1 || (_f$1 = __template$g(["\n  background-color: transparent;\n  position: absolute;\n  top: 0;\n  right: 0;\n"])));
var TextInputClearButton = styled_components_browser_esm_default(Button)({
  "&:not([hidden])": {
    display: "block"
  }
});
var TextInput = (0, import_react2.forwardRef)(function TextInput2(props, forwardedRef) {
  const {
    border: border2 = true,
    clearButton,
    disabled = false,
    fontSize: fontSizeProp = 2,
    icon,
    iconRight,
    onClear,
    padding: paddingProp = 3,
    prefix,
    radius: radiusProp = 1,
    readOnly,
    space: spaceProp = 3,
    suffix,
    customValidity,
    type = "text",
    weight,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  const rootTheme = useRootTheme();
  const fontSize2 = useArrayProp(fontSizeProp);
  const padding = useArrayProp(paddingProp);
  const radius = useArrayProp(radiusProp);
  const space = useArrayProp(spaceProp);
  const $hasClearButton = Boolean(clearButton);
  const $hasIcon = Boolean(icon);
  const $hasIconRight = Boolean(iconRight);
  const $hasSuffix = Boolean(suffix);
  const $hasPrefix = Boolean(prefix);
  useCustomValidity(ref, customValidity);
  const handleClearMouseDown = (0, import_react2.useCallback)((event) => {
    event.preventDefault();
    event.stopPropagation();
  }, []);
  const handleClearClick = (0, import_react2.useCallback)((event) => {
    var _a2;
    event.preventDefault();
    event.stopPropagation();
    if (onClear)
      onClear();
    (_a2 = ref.current) == null ? void 0 : _a2.focus();
  }, [onClear, ref]);
  const prefixNode = (0, import_react2.useMemo)(() => prefix && (0, import_jsx_runtime.jsx)(Prefix, {
    borderTop: true,
    borderLeft: true,
    borderBottom: true,
    radius,
    sizing: "border",
    tone: "inherit",
    children: (0, import_jsx_runtime.jsx)("span", {
      children: prefix
    })
  }), [prefix, radius]);
  const presentationNode = (0, import_react2.useMemo)(() => (0, import_jsx_runtime.jsxs)(Presentation, {
    $hasPrefix,
    $hasSuffix,
    $radius: radius,
    $scheme: rootTheme.scheme,
    $tone: rootTheme.tone,
    "data-border": border2 ? "" : void 0,
    "data-scheme": rootTheme.scheme,
    "data-tone": rootTheme.tone,
    children: [icon && (0, import_jsx_runtime.jsx)(LeftBox, {
      padding,
      children: (0, import_jsx_runtime.jsxs)(Text, {
        size: fontSize2,
        children: [(0, import_react2.isValidElement)(icon) && icon, (0, import_react_is.isValidElementType)(icon) && (0, import_react2.createElement)(icon)]
      })
    }), !$hasClearButton && iconRight && (0, import_jsx_runtime.jsx)(RightBox, {
      padding,
      children: (0, import_jsx_runtime.jsxs)(Text, {
        size: fontSize2,
        children: [(0, import_react2.isValidElement)(iconRight) && iconRight, (0, import_react_is.isValidElementType)(iconRight) && (0, import_react2.createElement)(iconRight)]
      })
    })]
  }), [border2, fontSize2, icon, iconRight, padding, radius, rootTheme, $hasClearButton, $hasPrefix, $hasSuffix]);
  const clearButtonBoxPadding = (0, import_react2.useMemo)(() => padding.map((v) => {
    if (v === 0)
      return 0;
    if (v === 1)
      return 1;
    if (v === 2)
      return 1;
    return v - 2;
  }), [padding]);
  const clearButtonPadding = (0, import_react2.useMemo)(() => padding.map((v) => {
    if (v === 0)
      return 0;
    if (v === 1)
      return 0;
    if (v === 2)
      return 1;
    return v - 1;
  }), [padding]);
  const clearButtonProps = (0, import_react2.useMemo)(() => typeof clearButton === "object" ? clearButton : EMPTY_RECORD, [clearButton]);
  const clearButtonNode = (0, import_react2.useMemo)(() => !disabled && !readOnly && clearButton && (0, import_jsx_runtime.jsx)(RightCard, {
    forwardedAs: "span",
    padding: clearButtonBoxPadding,
    style: CLEAR_BUTTON_BOX_STYLE,
    tone: customValidity ? "critical" : "inherit",
    children: (0, import_jsx_runtime.jsx)(TextInputClearButton, {
      "aria-label": "Clear",
      "data-qa": "clear-button",
      fontSize: fontSize2,
      icon: CloseIcon,
      mode: "bleed",
      padding: clearButtonPadding,
      radius,
      ...clearButtonProps,
      onClick: handleClearClick,
      onMouseDown: handleClearMouseDown
    })
  }), [clearButton, clearButtonBoxPadding, clearButtonPadding, clearButtonProps, customValidity, disabled, fontSize2, handleClearClick, handleClearMouseDown, radius, readOnly]);
  const suffixNode = (0, import_react2.useMemo)(() => suffix && (0, import_jsx_runtime.jsx)(Suffix, {
    borderTop: true,
    borderRight: true,
    borderBottom: true,
    radius,
    sizing: "border",
    tone: "inherit",
    children: (0, import_jsx_runtime.jsx)("span", {
      children: suffix
    })
  }), [radius, suffix]);
  return (0, import_jsx_runtime.jsxs)(Root$c, {
    "data-ui": "TextInput",
    tone: rootTheme.tone,
    children: [prefixNode, (0, import_jsx_runtime.jsxs)(InputRoot, {
      children: [(0, import_jsx_runtime.jsx)(Input, {
        "data-as": "input",
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone,
        ...restProps,
        $fontSize: fontSize2,
        $iconLeft: $hasIcon,
        $iconRight: $hasIconRight || $hasClearButton,
        $padding: padding,
        $scheme: rootTheme.scheme,
        $space: space,
        $tone: rootTheme.tone,
        $weight: weight,
        disabled,
        readOnly,
        ref,
        type
      }), presentationNode, clearButtonNode]
    }), suffixNode]
  });
});
function useDelayedState(initialState) {
  const [state, setState] = (0, import_react2.useState)(initialState);
  const delayedAction = (0, import_react2.useRef)();
  const onStateChange = (0, import_react2.useCallback)((nextState, delay) => {
    const action = () => {
      setState(nextState);
    };
    if (delayedAction.current) {
      clearTimeout(delayedAction.current);
      delayedAction.current = void 0;
    }
    if (!delay)
      return action();
    delayedAction.current = setTimeout(action, delay);
  }, []);
  return [state, onStateChange];
}
var DEFAULT_TOOLTIP_PADDING = 4;
var DEFAULT_FALLBACK_PLACEMENTS = {
  top: ["bottom", "left", "right"],
  "top-start": ["bottom-start", "left-start", "right-start"],
  "top-end": ["bottom-end", "left-end", "right-end"],
  bottom: ["top", "left", "right"],
  "bottom-start": ["top-start", "left-start", "right-start"],
  "bottom-end": ["top-end", "left-end", "right-end"],
  left: ["right", "top", "bottom"],
  "left-start": ["right-start", "top-start", "bottom-start"],
  "left-end": ["right-end", "top-end", "bottom-end"],
  right: ["left", "top", "bottom"],
  "right-start": ["left-start", "top-start", "bottom-start"],
  "right-end": ["left-end", "top-end", "bottom-end"]
};
var __freeze$f = Object.freeze;
var __defProp$f = Object.defineProperty;
var __template$f = (cooked, raw) => __freeze$f(__defProp$f(cooked, "raw", {
  value: __freeze$f(raw || cooked.slice())
}));
var _a$f;
var _b$9;
var _c$4;
var Root$b = styled_components_browser_esm_default.div(_a$f || (_a$f = __template$f(["\n  position: absolute;\n  pointer-events: none;\n  width: 15px;\n  height: 15px;\n  fill: none;\n\n  :empty + & {\n    display: none;\n  }\n\n  & > svg {\n    display: block;\n    transform-origin: 7.5px 7.5px;\n  }\n\n  /* position: absolute;\n  width: 15px;\n  height: 15px;\n  fill: none;\n\n  :empty + & {\n    display: none;\n  }\n\n  & > svg {\n    &:not([hidden]) {\n      display: block;\n    }\n    transform-origin: 7.5px 7.5px;\n  } */\n\n  [data-placement^='top'] > & {\n    bottom: -27px;\n  }\n\n  [data-placement^='right'] > & {\n    left: -27px;\n\n    & > svg {\n      transform: rotate(90deg);\n    }\n  }\n\n  [data-placement^='left'] > & {\n    right: -27px;\n\n    & > svg {\n      transform: rotate(-90deg);\n    }\n  }\n\n  [data-placement^='bottom'] > & {\n    top: -27px;\n\n    & > svg {\n      transform: rotate(180deg);\n    }\n  }\n"])));
var Border = styled_components_browser_esm_default.path(_b$9 || (_b$9 = __template$f(["\n  fill: var(--card-shadow-outline-color);\n"])));
var Shape = styled_components_browser_esm_default.path(_c$4 || (_c$4 = __template$f(["\n  fill: var(--card-bg-color);\n"])));
var TooltipArrow = (0, import_react2.forwardRef)(function TooltipArrow2(props, ref) {
  const {
    ...restProps
  } = props;
  return (0, import_jsx_runtime.jsx)(Root$b, {
    "data-ui": "Tooltip__arrow",
    ...restProps,
    ref,
    children: (0, import_jsx_runtime.jsxs)("svg", {
      width: "15",
      height: "15",
      viewBox: "0 0 15 15",
      children: [(0, import_jsx_runtime.jsx)(Border, {
        d: "M11.5266 1C11.032 1.32802 10.5837 1.73105 10.1995 2.20057L9.04792 3.6081C8.24771 4.58614 6.7523 4.58614 5.95209 3.6081L4.80047 2.20057C4.41632 1.73105 3.96796 1.32802 3.47341 1H0.156727C1.65639 1 3.07687 1.67313 4.02651 2.83381L5.17813 4.24134C6.37844 5.70839 8.62156 5.70839 9.82187 4.24134L10.9735 2.83381C11.9231 1.67313 13.3436 1 14.8433 1H11.5266Z"
      }), (0, import_jsx_runtime.jsx)(Shape, {
        d: "M0.156725 0C1.95632 0 3.66089 0.80776 4.80047 2.20057L5.95209 3.6081C6.75229 4.58614 8.24771 4.58614 9.04791 3.6081L10.1995 2.20057C11.3391 0.80776 13.0437 0 14.8433 0H15H0H0.156725Z"
      })]
    })
  });
});
var key$4 = Symbol.for("@sanity/ui/context/tooltipDelayGroup");
globalScope[key$4] = globalScope[key$4] || (0, import_react2.createContext)(null);
var TooltipDelayGroupContext = globalScope[key$4];
function useTooltipDelayGroup() {
  const value = (0, import_react2.useContext)(TooltipDelayGroupContext);
  return value;
}
var __freeze$e = Object.freeze;
var __defProp$e = Object.defineProperty;
var __template$e = (cooked, raw) => __freeze$e(__defProp$e(cooked, "raw", {
  value: __freeze$e(raw || cooked.slice())
}));
var _a$e;
var Root$a = styled_components_browser_esm_default(Layer)(_a$e || (_a$e = __template$e(["\n  pointer-events: none;\n  max-width: ", "px;\n"])), (_ref22) => {
  let {
    $maxWidth
  } = _ref22;
  return $maxWidth;
});
var Tooltip = (0, import_react2.forwardRef)(function Tooltip2(props, ref) {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  const boundaryElementContext = useBoundaryElement();
  const theme = useTheme();
  const {
    boundaryElement = boundaryElementContext == null ? void 0 : boundaryElementContext.element,
    children: childProp,
    content,
    disabled,
    fallbackPlacements: fallbackPlacementsProp = (_b2 = props.fallbackPlacements) != null ? _b2 : DEFAULT_FALLBACK_PLACEMENTS[(_a2 = props.placement) != null ? _a2 : "bottom"],
    padding,
    placement: placementProp = "bottom",
    portal: portalProp,
    scheme,
    shadow = 2,
    zOffset = (_c2 = theme.sanity.layer) == null ? void 0 : _c2.tooltip.zOffset,
    delay,
    ...restProps
  } = props;
  const fallbackPlacements = useArrayProp(fallbackPlacementsProp);
  const forwardedRef = useForwardedRef(ref);
  const [referenceElement, setReferenceElement] = (0, import_react2.useState)(null);
  const arrowRef = (0, import_react2.useRef)(null);
  const rootBoundary = "viewport";
  const portal = usePortal();
  const portalElement = typeof portalProp === "string" ? ((_d2 = portal.elements) == null ? void 0 : _d2[portalProp]) || null : portal.element;
  const tooltipWidth = (0, import_react2.useMemo)(() => {
    const availableWidths = [...boundaryElement ? [boundaryElement.offsetWidth] : [], (portalElement == null ? void 0 : portalElement.offsetWidth) || document.body.offsetWidth];
    return Math.min(...availableWidths) - DEFAULT_TOOLTIP_PADDING * 2;
  }, [boundaryElement, portalElement == null ? void 0 : portalElement.offsetWidth]);
  const middleware = (0, import_react2.useMemo)(() => {
    const ret = [];
    ret.push(flip({
      boundary: boundaryElement || void 0,
      fallbackPlacements,
      padding: DEFAULT_TOOLTIP_PADDING,
      rootBoundary
    }));
    ret.push(offset({
      mainAxis: 3
    }));
    ret.push(shift({
      boundary: boundaryElement || void 0,
      rootBoundary,
      padding: DEFAULT_TOOLTIP_PADDING
    }));
    ret.push(arrow2({
      element: arrowRef,
      padding: 2
    }));
    return ret;
  }, [boundaryElement, fallbackPlacements]);
  const {
    floatingStyles,
    placement,
    middlewareData,
    refs,
    update
  } = useFloating({
    middleware,
    placement: placementProp,
    whileElementsMounted: autoUpdate
  });
  const staticSide = placement && FLOATING_STATIC_SIDES[placement.split("-")[0]];
  const arrowX = (_e2 = middlewareData.arrow) == null ? void 0 : _e2.x;
  const arrowY = (_f2 = middlewareData.arrow) == null ? void 0 : _f2.y;
  const arrowStyle = (0, import_react2.useMemo)(() => {
    const style = {
      left: arrowX !== null ? arrowX : void 0,
      top: arrowY !== null ? arrowY : void 0,
      right: void 0,
      bottom: void 0
    };
    if (staticSide)
      style[staticSide] = -15;
    return style;
  }, [arrowX, arrowY, staticSide]);
  const tooltipId = (0, import_react2.useId)();
  const [isOpen, setIsOpen] = useDelayedState(false);
  const delayGroupContext = useTooltipDelayGroup();
  const showTooltip = isOpen || (delayGroupContext == null ? void 0 : delayGroupContext.openTooltipId) === tooltipId;
  const isInsideGroup = delayGroupContext !== null;
  const openDelayProp = typeof delay === "number" ? delay : (delay == null ? void 0 : delay.open) || 0;
  const closeDelayProp = typeof delay === "number" ? delay : (delay == null ? void 0 : delay.close) || 0;
  const openDelay = isInsideGroup ? delayGroupContext.openDelay : openDelayProp;
  const closeDelay = isInsideGroup ? delayGroupContext.closeDelay : closeDelayProp;
  const handleIsOpenChange = (0, import_react2.useCallback)((open, immediate) => {
    if (isInsideGroup) {
      if (open) {
        const groupedOpenDelay = immediate ? 0 : openDelay;
        delayGroupContext.setIsGroupActive(open, groupedOpenDelay);
        delayGroupContext.setOpenTooltipId(tooltipId, groupedOpenDelay);
      } else {
        const minimumGroupDeactivateDelay = 200;
        const groupDeactivateDelay = closeDelay > minimumGroupDeactivateDelay ? closeDelay : minimumGroupDeactivateDelay;
        delayGroupContext.setIsGroupActive(open, groupDeactivateDelay);
        delayGroupContext.setOpenTooltipId(null, immediate ? 0 : closeDelay);
      }
    } else {
      const standaloneDelay = immediate ? 0 : open ? openDelay : closeDelay;
      setIsOpen(open, standaloneDelay);
    }
  }, [isInsideGroup, delayGroupContext, openDelay, tooltipId, closeDelay, setIsOpen]);
  const handleBlur = (0, import_react2.useCallback)((e) => {
    var _a3, _b22;
    handleIsOpenChange(false);
    (_b22 = (_a3 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a3.onBlur) == null ? void 0 : _b22.call(_a3, e);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleClick = (0, import_react2.useCallback)((e) => {
    var _a3, _b22;
    handleIsOpenChange(false, true);
    (_b22 = childProp == null ? void 0 : (_a3 = childProp.props).onClick) == null ? void 0 : _b22.call(_a3, e);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleContextMenu = (0, import_react2.useCallback)((e) => {
    var _a3, _b22;
    handleIsOpenChange(false, true);
    (_b22 = childProp == null ? void 0 : (_a3 = childProp.props).onContextMenu) == null ? void 0 : _b22.call(_a3, e);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleFocus = (0, import_react2.useCallback)((e) => {
    var _a3, _b22;
    handleIsOpenChange(true);
    (_b22 = (_a3 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a3.onFocus) == null ? void 0 : _b22.call(_a3, e);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleMouseEnter = (0, import_react2.useCallback)((e) => {
    var _a3, _b22;
    handleIsOpenChange(true);
    (_b22 = (_a3 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a3.onMouseEnter) == null ? void 0 : _b22.call(_a3, e);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  const handleMouseLeave = (0, import_react2.useCallback)((e) => {
    var _a3, _b22;
    handleIsOpenChange(false);
    (_b22 = (_a3 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a3.onMouseLeave) == null ? void 0 : _b22.call(_a3, e);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  (0, import_react2.useEffect)(() => {
    if (!isOpen)
      return;
    function handleWindowMouseMove(event) {
      if (!referenceElement)
        return;
      const isHoveringReference = referenceElement === event.target || event.target instanceof Node && referenceElement.contains(event.target);
      if (!isHoveringReference) {
        handleIsOpenChange(false);
        window.removeEventListener("mousemove", handleWindowMouseMove);
      }
    }
    window.addEventListener("mousemove", handleWindowMouseMove);
    return () => {
      window.removeEventListener("mousemove", handleWindowMouseMove);
    };
  }, [isOpen, referenceElement, handleIsOpenChange]);
  (0, import_react2.useEffect)(() => {
    if (disabled)
      handleIsOpenChange(false);
  }, [disabled, handleIsOpenChange]);
  (0, import_react2.useEffect)(() => {
    if (!content)
      handleIsOpenChange(false);
  }, [content, handleIsOpenChange]);
  (0, import_react2.useEffect)(() => refs.setReference(referenceElement), [referenceElement, refs]);
  (0, import_react2.useEffect)(() => {
    if (!showTooltip)
      return;
    function handleWindowKeyDown(event) {
      if (event.key === "Escape") {
        handleIsOpenChange(false, true);
      }
    }
    window.addEventListener("keydown", handleWindowKeyDown);
    return () => {
      window.removeEventListener("keydown", handleWindowKeyDown);
    };
  }, [handleIsOpenChange, showTooltip]);
  const setArrow = (0, import_react2.useCallback)((arrowEl) => {
    arrowRef.current = arrowEl;
    update();
  }, [update]);
  const setFloating = (0, import_react2.useCallback)((node) => {
    forwardedRef.current = node;
    refs.setFloating(node);
  }, [forwardedRef, refs]);
  const childRef = childProp == null ? void 0 : childProp.ref;
  const setReference = (0, import_react2.useCallback)((node) => {
    if (typeof childRef === "function") {
      childRef(node);
    } else if (childRef) {
      childRef.current = node;
    }
    setReferenceElement(node);
  }, [childRef]);
  const child = (0, import_react2.useMemo)(() => {
    if (!childProp)
      return null;
    return (0, import_react2.cloneElement)(childProp, {
      onBlur: handleBlur,
      onFocus: handleFocus,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onClick: handleClick,
      onContextMenu: handleContextMenu,
      ref: setReference
    });
  }, [childProp, handleBlur, handleClick, handleContextMenu, handleFocus, handleMouseEnter, handleMouseLeave, setReference]);
  if (!child)
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
  if (disabled)
    return child;
  const root = (0, import_jsx_runtime.jsx)(Root$a, {
    "data-ui": "Tooltip",
    ...restProps,
    ref: setFloating,
    style: floatingStyles,
    zOffset,
    $maxWidth: tooltipWidth,
    children: (0, import_jsx_runtime.jsxs)(Card, {
      "data-ui": "Tooltip__card",
      "data-placement": placement,
      padding,
      radius: 2,
      scheme,
      shadow,
      children: [content, (0, import_jsx_runtime.jsx)(TooltipArrow, {
        ref: setArrow,
        style: arrowStyle
      })]
    })
  });
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [child, showTooltip && (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
      children: portalProp ? (0, import_jsx_runtime.jsx)(Portal, {
        __unstable_name: typeof portalProp === "string" ? portalProp : void 0,
        children: root
      }) : root
    })]
  });
});
var __freeze$d = Object.freeze;
var __defProp$d = Object.defineProperty;
var __template$d = (cooked, raw) => __freeze$d(__defProp$d(cooked, "raw", {
  value: __freeze$d(raw || cooked.slice())
}));
var _a$d;
var _b$8;
var _c$3;
var _d$2;
var Root$9 = styled_components_browser_esm_default.div(_a$d || (_a$d = __template$d(["\n  line-height: 0;\n"])));
var ListBox = styled_components_browser_esm_default(Box)(_b$8 || (_b$8 = __template$d(["\n  & > ul {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n  }\n"])));
var rotate = We(_c$3 || (_c$3 = __template$d(["\n  from {\n    transform: rotate(0deg);\n  }\n\n  to {\n    transform: rotate(360deg);\n  }\n"])));
var AnimatedSpinnerIcon = styled_components_browser_esm_default(SpinnerIcon)(_d$2 || (_d$2 = __template$d(["\n  animation: ", " 500ms linear infinite;\n"])), rotate);
function AutocompleteOption(props) {
  const {
    children,
    id,
    onSelect,
    selected,
    value
  } = props;
  const handleClick = (0, import_react2.useCallback)(() => {
    setTimeout(() => {
      onSelect(value);
    }, 0);
  }, [onSelect, value]);
  const handleKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "Enter" && !_isEnterToClickElement(event.currentTarget)) {
      handleClick();
    }
  }, [handleClick]);
  return (0, import_jsx_runtime.jsx)("li", {
    "aria-selected": selected,
    "data-ui": "AutocompleteOption",
    id,
    role: "option",
    onClick: handleClick,
    onKeyDown: handleKeyDown,
    children
  });
}
function autocompleteReducer(state, msg2) {
  if (msg2.type === "input/change") {
    return {
      ...state,
      activeValue: null,
      focused: true,
      query: msg2.query
    };
  }
  if (msg2.type === "input/focus") {
    return {
      ...state,
      focused: true
    };
  }
  if (msg2.type === "root/blur") {
    return {
      ...state,
      focused: false,
      query: null
    };
  }
  if (msg2.type === "root/clear") {
    return {
      ...state,
      activeValue: null,
      query: null,
      value: null
    };
  }
  if (msg2.type === "root/escape") {
    return {
      ...state,
      focused: false,
      query: null
    };
  }
  if (msg2.type === "root/open") {
    return {
      ...state,
      query: state.query || msg2.query
    };
  }
  if (msg2.type === "root/setActiveValue") {
    return {
      ...state,
      activeValue: msg2.value,
      listFocused: msg2.listFocused || state.listFocused
    };
  }
  if (msg2.type === "root/setListFocused") {
    return {
      ...state,
      listFocused: msg2.listFocused
    };
  }
  if (msg2.type === "value/change") {
    return {
      ...state,
      activeValue: msg2.value,
      query: null,
      value: msg2.value
    };
  }
  return state;
}
var AUTOCOMPLETE_LISTBOX_IGNORE_KEYS = ["Control", "Shift", "Alt", "Enter", "Home", "End", "PageUp", "PageDown", "Meta", "Tab", "CapsLock"];
var AUTOCOMPLETE_POPOVER_PLACEMENT = "bottom-start";
var AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS = ["bottom-start", "top-start"];
var DEFAULT_RENDER_VALUE = (value, option) => option ? option.value : value;
var DEFAULT_FILTER_OPTION = (query, option) => option.value.toLowerCase().indexOf(query.toLowerCase()) > -1;
var InnerAutocomplete = (0, import_react2.forwardRef)(function InnerAutocomplete2(props, ref) {
  const {
    border: border2 = true,
    customValidity,
    disabled,
    filterOption: filterOptionProp,
    fontSize: fontSize2 = 2,
    icon,
    id,
    listBox = EMPTY_RECORD,
    loading,
    onBlur,
    onChange,
    onFocus,
    onQueryChange,
    onSelect,
    openButton,
    options: optionsProp,
    padding: paddingProp = 3,
    popover = EMPTY_RECORD,
    prefix,
    radius = 3,
    readOnly,
    relatedElements,
    renderOption: renderOptionProp,
    renderPopover,
    renderValue = DEFAULT_RENDER_VALUE,
    suffix,
    value: valueProp,
    ...restProps
  } = props;
  const [state, dispatch] = (0, import_react2.useReducer)(autocompleteReducer, {
    activeValue: valueProp || null,
    focused: false,
    listFocused: false,
    query: null,
    value: valueProp || null
  });
  const {
    activeValue,
    focused,
    listFocused,
    query,
    value
  } = state;
  const defaultRenderOption = (0, import_react2.useCallback)((_ref23) => {
    let {
      value: value2
    } = _ref23;
    return (0, import_jsx_runtime.jsx)(Card, {
      "data-as": "button",
      padding: paddingProp,
      radius: 2,
      tone: "inherit",
      children: (0, import_jsx_runtime.jsx)(Text, {
        size: fontSize2,
        textOverflow: "ellipsis",
        children: value2
      })
    });
  }, [fontSize2, paddingProp]);
  const renderOption = typeof renderOptionProp === "function" ? renderOptionProp : defaultRenderOption;
  const filterOption = typeof filterOptionProp === "function" ? filterOptionProp : DEFAULT_FILTER_OPTION;
  const rootElementRef = (0, import_react2.useRef)(null);
  const resultsPopoverElementRef = (0, import_react2.useRef)(null);
  const inputElementRef = (0, import_react2.useRef)(null);
  const listBoxElementRef = (0, import_react2.useRef)(null);
  const listFocusedRef = (0, import_react2.useRef)(false);
  const valueRef = (0, import_react2.useRef)(value);
  const valuePropRef = (0, import_react2.useRef)(valueProp);
  const popoverMouseWithinRef = (0, import_react2.useRef)(false);
  const forwardedRef = useForwardedRef(ref);
  const listBoxId = "".concat(id, "-listbox");
  const options = Array.isArray(optionsProp) ? optionsProp : EMPTY_ARRAY;
  const padding = useArrayProp(paddingProp);
  const currentOption = (0, import_react2.useMemo)(() => value !== null ? options.find((o) => o.value === value) : void 0, [options, value]);
  const filteredOptions = (0, import_react2.useMemo)(() => options.filter((option) => query ? filterOption(query, option) : true), [filterOption, options, query]);
  const filteredOptionsLen = filteredOptions.length;
  const activeItemId = activeValue ? "".concat(id, "-option-").concat(activeValue) : void 0;
  const expanded = query !== null && loading || focused && query !== null;
  const handleRootBlur = (0, import_react2.useCallback)((event) => {
    setTimeout(() => {
      if (popoverMouseWithinRef.current) {
        return;
      }
      const elements = (relatedElements || []).concat(rootElementRef.current ? [rootElementRef.current] : [], resultsPopoverElementRef.current ? [resultsPopoverElementRef.current] : []);
      let focusInside = false;
      if (document.activeElement) {
        for (const e of elements) {
          if (e === document.activeElement || e.contains(document.activeElement)) {
            focusInside = true;
            break;
          }
        }
      }
      if (focusInside === false) {
        dispatch({
          type: "root/blur"
        });
        popoverMouseWithinRef.current = false;
        if (onQueryChange)
          onQueryChange(null);
        if (onBlur)
          onBlur(event);
      }
    }, 0);
  }, [onBlur, onQueryChange, relatedElements]);
  const handleRootFocus = (0, import_react2.useCallback)((event) => {
    const listBoxElement = listBoxElementRef.current;
    const focusedElement = event.target instanceof HTMLElement ? event.target : null;
    const listFocused2 = (listBoxElement == null ? void 0 : listBoxElement.contains(focusedElement)) || false;
    if (listFocused2 !== listFocusedRef.current) {
      listFocusedRef.current = listFocused2;
      dispatch({
        type: "root/setListFocused",
        listFocused: listFocused2
      });
    }
  }, []);
  const handleOptionSelect = (0, import_react2.useCallback)((v) => {
    var _a2;
    dispatch({
      type: "value/change",
      value: v
    });
    popoverMouseWithinRef.current = false;
    if (onSelect)
      onSelect(v);
    valueRef.current = v;
    if (onChange)
      onChange(v);
    if (onQueryChange)
      onQueryChange(null);
    (_a2 = inputElementRef.current) == null ? void 0 : _a2.focus();
  }, [onChange, onSelect, onQueryChange]);
  const handleRootKeyDown = (0, import_react2.useCallback)((event) => {
    var _a2, _b2;
    if (event.key === "ArrowDown") {
      event.preventDefault();
      if (!filteredOptionsLen)
        return;
      const activeOption = filteredOptions.find((o) => o.value === activeValue);
      const activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1;
      const nextActiveOption = filteredOptions[(activeIndex + 1) % filteredOptionsLen];
      if (nextActiveOption) {
        dispatch({
          type: "root/setActiveValue",
          value: nextActiveOption.value,
          listFocused: true
        });
      }
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      if (!filteredOptionsLen)
        return;
      const activeOption = filteredOptions.find((o) => o.value === activeValue);
      const activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1;
      const nextActiveOption = filteredOptions[activeIndex === -1 ? filteredOptionsLen - 1 : (filteredOptionsLen + activeIndex - 1) % filteredOptionsLen];
      if (nextActiveOption) {
        dispatch({
          type: "root/setActiveValue",
          value: nextActiveOption.value,
          listFocused: true
        });
      }
      return;
    }
    if (event.key === "Escape") {
      dispatch({
        type: "root/escape"
      });
      popoverMouseWithinRef.current = false;
      if (onQueryChange)
        onQueryChange(null);
      (_a2 = inputElementRef.current) == null ? void 0 : _a2.focus();
      return;
    }
    const target = event.target;
    const listEl = listBoxElementRef.current;
    if ((listEl === target || (listEl == null ? void 0 : listEl.contains(target))) && !AUTOCOMPLETE_LISTBOX_IGNORE_KEYS.includes(event.key)) {
      (_b2 = inputElementRef.current) == null ? void 0 : _b2.focus();
      return;
    }
  }, [activeValue, filteredOptions, filteredOptionsLen, onQueryChange]);
  const handleInputChange = (0, import_react2.useCallback)((event) => {
    const nextQuery = event.currentTarget.value;
    dispatch({
      type: "input/change",
      query: nextQuery
    });
    if (onQueryChange)
      onQueryChange(nextQuery);
  }, [onQueryChange]);
  const handleInputFocus = (0, import_react2.useCallback)((event) => {
    if (!focused) {
      dispatch({
        type: "input/focus"
      });
      if (onFocus)
        onFocus(event);
    }
  }, [focused, onFocus]);
  const handlePopoverMouseEnter = (0, import_react2.useCallback)(() => {
    popoverMouseWithinRef.current = true;
  }, []);
  const handlePopoverMouseLeave = (0, import_react2.useCallback)(() => {
    popoverMouseWithinRef.current = false;
  }, []);
  const handleClearButtonClick = (0, import_react2.useCallback)(() => {
    var _a2;
    dispatch({
      type: "root/clear"
    });
    valueRef.current = "";
    if (onChange)
      onChange("");
    if (onQueryChange)
      onQueryChange(null);
    (_a2 = inputElementRef.current) == null ? void 0 : _a2.focus();
  }, [onChange, onQueryChange]);
  const handleClearButtonFocus = (0, import_react2.useCallback)(() => {
    dispatch({
      type: "input/focus"
    });
  }, []);
  (0, import_react2.useEffect)(() => {
    if (valueProp !== valuePropRef.current) {
      valuePropRef.current = valueProp;
      if (valueProp !== void 0) {
        dispatch({
          type: "value/change",
          value: valueProp
        });
        valueRef.current = valueProp;
      }
      return;
    }
    if (valueProp !== valueRef.current) {
      valueRef.current = valueProp || null;
      dispatch({
        type: "value/change",
        value: valueProp || null
      });
    }
  }, [valueProp]);
  (0, import_react2.useEffect)(() => {
    if (!focused && valueRef.current) {
      dispatch({
        type: "root/setActiveValue",
        value: valueRef.current
      });
    }
  }, [focused]);
  (0, import_react2.useEffect)(() => {
    const listElement = listBoxElementRef.current;
    if (!listElement)
      return;
    const activeOption = filteredOptions.find((o) => o.value === activeValue);
    if (activeOption) {
      const activeIndex = filteredOptions.indexOf(activeOption);
      const activeItemElement = listElement.childNodes[activeIndex];
      if (activeItemElement) {
        if (_hasFocus(activeItemElement)) {
          return;
        }
        focusFirstDescendant(activeItemElement);
      }
    }
  }, [activeValue, filteredOptions]);
  const setRef = (0, import_react2.useCallback)((el) => {
    inputElementRef.current = el;
    forwardedRef.current = el;
  }, [forwardedRef]);
  const clearButton = (0, import_react2.useMemo)(() => {
    if (!loading && !disabled && value) {
      return {
        "aria-label": "Clear",
        onFocus: handleClearButtonFocus
      };
    }
    return void 0;
  }, [disabled, handleClearButtonFocus, loading, value]);
  const openButtonBoxPadding = (0, import_react2.useMemo)(() => padding.map((v) => {
    if (v === 0)
      return 0;
    if (v === 1)
      return 1;
    if (v === 2)
      return 1;
    return v - 2;
  }), [padding]);
  const openButtonPadding = (0, import_react2.useMemo)(() => padding.map((v) => Math.max(v - 1, 0)), [padding]);
  const openButtonProps = (0, import_react2.useMemo)(() => typeof openButton === "object" ? openButton : EMPTY_RECORD, [openButton]);
  const handleOpenClick = (0, import_react2.useCallback)((event) => {
    dispatch({
      type: "root/open",
      query: value ? renderValue(value, currentOption) : ""
    });
    if (openButtonProps.onClick)
      openButtonProps.onClick(event);
    _raf(() => {
      var _a2;
      return (_a2 = inputElementRef.current) == null ? void 0 : _a2.focus();
    });
  }, [currentOption, openButtonProps, renderValue, value]);
  const openButtonNode = (0, import_react2.useMemo)(() => !disabled && !readOnly && openButton ? (0, import_jsx_runtime.jsx)(Box, {
    "aria-hidden": expanded,
    padding: openButtonBoxPadding,
    children: (0, import_jsx_runtime.jsx)(Button, {
      "aria-label": "Open",
      disabled: expanded,
      fontSize: fontSize2,
      icon: ChevronDownIcon,
      mode: "bleed",
      padding: openButtonPadding,
      ...openButtonProps,
      onClick: handleOpenClick
    })
  }) : void 0, [disabled, expanded, fontSize2, handleOpenClick, openButton, openButtonBoxPadding, openButtonPadding, openButtonProps, readOnly]);
  const inputValue = (0, import_react2.useMemo)(() => {
    if (query === null) {
      if (value !== null) {
        return renderValue(value, currentOption);
      }
      return "";
    }
    return query;
  }, [currentOption, query, renderValue, value]);
  const input = (0, import_jsx_runtime.jsx)(TextInput, {
    ...restProps,
    "aria-activedescendant": activeItemId,
    "aria-autocomplete": "list",
    "aria-expanded": expanded,
    "aria-owns": listBoxId,
    autoCapitalize: "off",
    autoComplete: "off",
    autoCorrect: "off",
    border: border2,
    clearButton,
    customValidity,
    disabled,
    fontSize: fontSize2,
    icon,
    iconRight: loading && AnimatedSpinnerIcon,
    id,
    inputMode: "search",
    onChange: handleInputChange,
    onClear: handleClearButtonClick,
    onFocus: handleInputFocus,
    padding,
    prefix,
    radius,
    readOnly,
    ref: setRef,
    role: "combobox",
    spellCheck: false,
    suffix: suffix || openButtonNode,
    value: inputValue
  });
  const handleListBoxKeyDown = (0, import_react2.useCallback)((event) => {
    var _a2;
    if (event.key === "Tab") {
      if (listFocused)
        (_a2 = inputElementRef.current) == null ? void 0 : _a2.focus();
    }
  }, [listFocused]);
  const content = (0, import_react2.useMemo)(() => {
    if (filteredOptions.length === 0)
      return null;
    return (0, import_jsx_runtime.jsx)(ListBox, {
      "data-ui": "AutoComplete__results",
      onKeyDown: handleListBoxKeyDown,
      padding: 1,
      ...listBox,
      tabIndex: -1,
      children: (0, import_jsx_runtime.jsx)(Stack, {
        as: "ul",
        "aria-multiselectable": false,
        "data-ui": "AutoComplete__resultsList",
        id: listBoxId,
        ref: listBoxElementRef,
        role: "listbox",
        space: 1,
        children: filteredOptions.map((option) => {
          const active = activeValue !== null ? option.value === activeValue : currentOption === option;
          return (0, import_jsx_runtime.jsx)(AutocompleteOption, {
            id: "".concat(id, "-option-").concat(option.value),
            onSelect: handleOptionSelect,
            selected: active,
            value: option.value,
            children: (0, import_react2.cloneElement)(renderOption(option), {
              disabled: loading,
              selected: active,
              tabIndex: listFocused && active ? 0 : -1
            })
          }, option.value);
        })
      })
    });
  }, [activeValue, currentOption, filteredOptions, handleOptionSelect, handleListBoxKeyDown, id, listBox, listBoxId, listFocused, loading, renderOption]);
  const results = (0, import_react2.useMemo)(() => {
    if (renderPopover) {
      return renderPopover({
        content,
        hidden: !expanded,
        inputElement: inputElementRef.current,
        onMouseEnter: handlePopoverMouseEnter,
        onMouseLeave: handlePopoverMouseLeave
      }, resultsPopoverElementRef);
    }
    if (filteredOptionsLen === 0) {
      return null;
    }
    return (0, import_jsx_runtime.jsx)(Popover, {
      arrow: false,
      constrainSize: true,
      content,
      fallbackPlacements: AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS,
      matchReferenceWidth: true,
      onMouseEnter: handlePopoverMouseEnter,
      onMouseLeave: handlePopoverMouseLeave,
      open: expanded,
      overflow: "auto",
      placement: AUTOCOMPLETE_POPOVER_PLACEMENT,
      portal: true,
      radius,
      ref: resultsPopoverElementRef,
      referenceElement: inputElementRef.current,
      ...popover
    });
  }, [content, expanded, filteredOptionsLen, handlePopoverMouseEnter, handlePopoverMouseLeave, popover, radius, renderPopover]);
  return (0, import_jsx_runtime.jsxs)(Root$9, {
    "data-ui": "Autocomplete",
    onBlur: handleRootBlur,
    onFocus: handleRootFocus,
    onKeyDown: handleRootKeyDown,
    ref: rootElementRef,
    children: [input, results]
  });
});
var __freeze$c = Object.freeze;
var __defProp$c = Object.defineProperty;
var __template$c = (cooked, raw) => __freeze$c(__defProp$c(cooked, "raw", {
  value: __freeze$c(raw || cooked.slice())
}));
var _a$c;
var _b$7;
var Root$8 = styled_components_browser_esm_default.ol(_a$c || (_a$c = __template$c(["\n  margin: 0;\n  padding: 0;\n  display: flex;\n  list-style: none;\n  align-items: center;\n  white-space: nowrap;\n  line-height: 0;\n"])));
var ExpandButton = styled_components_browser_esm_default(Button)(_b$7 || (_b$7 = __template$c(["\n  appearance: none;\n  margin: -4px;\n"])));
var Breadcrumbs = (0, import_react2.forwardRef)(function Breadcrumbs2(props, ref) {
  const {
    children,
    maxLength,
    separator,
    space: spaceRaw = 2,
    ...restProps
  } = props;
  const space = useArrayProp(spaceRaw);
  const [open, setOpen] = (0, import_react2.useState)(false);
  const [expandElement, setExpandElement] = (0, import_react2.useState)(null);
  const [popoverElement, setPopoverElement] = (0, import_react2.useState)(null);
  const collapse = (0, import_react2.useCallback)(() => setOpen(false), []);
  const expand = (0, import_react2.useCallback)(() => setOpen(true), []);
  useClickOutside(collapse, [expandElement, popoverElement]);
  const rawItems = (0, import_react2.useMemo)(() => import_react2.Children.toArray(children).filter((child) => {
    return (0, import_react2.isValidElement)(child);
  }), [children]);
  const items = (0, import_react2.useMemo)(() => {
    const len = rawItems.length;
    if (maxLength && len > maxLength) {
      const beforeLength = Math.ceil(maxLength / 2);
      const afterLength = Math.floor(maxLength / 2);
      return [...rawItems.slice(0, beforeLength - 1), (0, import_jsx_runtime.jsx)(Popover, {
        constrainSize: true,
        content: (0, import_jsx_runtime.jsx)(Stack, {
          as: "ol",
          overflow: "auto",
          padding: space,
          space,
          children: rawItems.slice(beforeLength - 1, len - afterLength)
        }),
        open,
        placement: "top",
        portal: true,
        ref: setPopoverElement,
        children: (0, import_jsx_runtime.jsx)(ExpandButton, {
          fontSize: 1,
          mode: "bleed",
          onClick: open ? collapse : expand,
          padding: 1,
          ref: setExpandElement,
          selected: open,
          text: ""
        })
      }, "button"), ...rawItems.slice(len - afterLength)];
    }
    return rawItems;
  }, [collapse, expand, maxLength, open, rawItems, space]);
  return (0, import_jsx_runtime.jsx)(Root$8, {
    "data-ui": "Breadcrumbs",
    ...restProps,
    ref,
    children: items.map((item, itemIndex) => (0, import_jsx_runtime.jsxs)(import_react2.Fragment, {
      children: [itemIndex > 0 && (0, import_jsx_runtime.jsx)(Box, {
        "aria-hidden": true,
        as: "li",
        paddingX: space,
        children: separator || (0, import_jsx_runtime.jsx)(Text, {
          muted: true,
          children: "/"
        })
      }), (0, import_jsx_runtime.jsx)(Box, {
        as: "li",
        children: item
      })]
    }, itemIndex))
  });
});
function dialogStyle(_ref24) {
  let {
    theme
  } = _ref24;
  const color2 = theme.sanity.color.base;
  return {
    "&:not([hidden])": {
      display: "flex"
    },
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
    outline: "none",
    background: color2.shadow.umbra
  };
}
function responsiveDialogPositionStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$position, (position) => ({
    "&&": {
      position
    }
  }));
}
var key$3 = Symbol.for("@sanity/ui/context/dialog");
globalScope[key$3] = globalScope[key$3] || (0, import_react2.createContext)({
  version: 0
});
var DialogContext = globalScope[key$3];
function useDialog() {
  return (0, import_react2.useContext)(DialogContext);
}
var __freeze$b = Object.freeze;
var __defProp$b = Object.defineProperty;
var __template$b = (cooked, raw) => __freeze$b(__defProp$b(cooked, "raw", {
  value: __freeze$b(raw || cooked.slice())
}));
var _a$b;
var _b$6;
var _c$2;
var _d$1;
var _e;
var _f;
function isTargetWithinScope(boundaryElement, portalElement, target) {
  if (!boundaryElement || !portalElement)
    return true;
  return containsOrEqualsElement(boundaryElement, target) || containsOrEqualsElement(portalElement, target);
}
var Root$7 = styled_components_browser_esm_default(Layer)(responsivePaddingStyle, dialogStyle, responsiveDialogPositionStyle);
var DialogContainer = styled_components_browser_esm_default(Container)(_a$b || (_a$b = __template$b(["\n  &:not([hidden]) {\n    display: flex;\n  }\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n"])));
var DialogCardRoot = styled_components_browser_esm_default(Card)(_b$6 || (_b$6 = __template$b(["\n  &:not([hidden]) {\n    display: flex;\n  }\n  width: 100%;\n  min-height: 0;\n  max-height: 100%;\n  overflow: hidden;\n  overflow: clip;\n"])));
var DialogLayout = styled_components_browser_esm_default(Flex)(_c$2 || (_c$2 = __template$b(["\n  flex: 1;\n  min-height: 0;\n  width: 100%;\n"])));
var DialogHeader = styled_components_browser_esm_default(Card)(_d$1 || (_d$1 = __template$b(["\n  position: relative;\n  z-index: 2;\n\n  &:after {\n    content: '';\n    display: block;\n    position: absolute;\n    left: 0;\n    right: 0;\n    bottom: -1px;\n    border-bottom: 1px solid var(--card-hairline-soft-color);\n  }\n"])));
var DialogContent = styled_components_browser_esm_default(Box)(_e || (_e = __template$b(["\n  position: relative;\n  z-index: 1;\n  overflow: auto;\n  outline: none;\n"])));
var DialogFooter = styled_components_browser_esm_default(Box)(_f || (_f = __template$b(["\n  position: relative;\n  z-index: 3;\n  border-top: 1px solid var(--card-hairline-soft-color);\n"])));
var DialogCard = (0, import_react2.forwardRef)(function DialogCard2(props, ref) {
  var _a2;
  const {
    __unstable_autoFocus: autoFocus,
    __unstable_hideCloseButton: hideCloseButton,
    children,
    contentRef,
    footer,
    header,
    id,
    onClickOutside,
    onClose,
    portal: portalProp,
    radius: radiusProp,
    scheme,
    shadow: shadowProp,
    width: widthProp
  } = props;
  const portal = usePortal();
  const portalElement = portalProp ? ((_a2 = portal.elements) == null ? void 0 : _a2[portalProp]) || null : portal.element;
  const boundaryElement = useBoundaryElement().element;
  const radius = useArrayProp(radiusProp);
  const shadow = useArrayProp(shadowProp);
  const width = useArrayProp(widthProp);
  const forwardedRef = useForwardedRef(ref);
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const localContentRef = (0, import_react2.useRef)(null);
  const layer = useLayer();
  const {
    isTopLayer
  } = layer;
  const labelId = "".concat(id, "_label");
  const showCloseButton = Boolean(onClose) && hideCloseButton === false;
  const showHeader = Boolean(header) || showCloseButton;
  (0, import_react2.useEffect)(() => {
    if (!autoFocus)
      return;
    if (forwardedRef.current) {
      focusFirstDescendant(forwardedRef.current);
    }
  }, [autoFocus, forwardedRef]);
  useGlobalKeyDown((0, import_react2.useCallback)((event) => {
    if (!isTopLayer || !onClose)
      return;
    const target = document.activeElement;
    if (target && !isTargetWithinScope(boundaryElement, portalElement, target)) {
      return;
    }
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      onClose();
    }
  }, [boundaryElement, isTopLayer, onClose, portalElement]));
  useClickOutside((0, import_react2.useCallback)((event) => {
    if (!isTopLayer || !onClickOutside)
      return;
    const target = event.target;
    if (target && !isTargetWithinScope(boundaryElement, portalElement, target)) {
      return;
    }
    onClickOutside();
  }, [boundaryElement, isTopLayer, onClickOutside, portalElement]), [rootElement]);
  const setRef = (0, import_react2.useCallback)((el) => {
    setRootElement(el);
    forwardedRef.current = el;
  }, [forwardedRef]);
  const setContentRef = (0, import_react2.useCallback)((el) => {
    localContentRef.current = el;
    if (typeof contentRef === "function")
      contentRef(el);
    else if (contentRef)
      contentRef.current = el;
  }, [contentRef]);
  return (0, import_jsx_runtime.jsx)(DialogContainer, {
    "data-ui": "DialogCard",
    width,
    children: (0, import_jsx_runtime.jsx)(DialogCardRoot, {
      radius,
      ref: setRef,
      scheme,
      shadow,
      children: (0, import_jsx_runtime.jsxs)(DialogLayout, {
        direction: "column",
        children: [showHeader && (0, import_jsx_runtime.jsx)(DialogHeader, {
          children: (0, import_jsx_runtime.jsxs)(Flex, {
            children: [(0, import_jsx_runtime.jsx)(Box, {
              flex: 1,
              padding: 4,
              children: header && (0, import_jsx_runtime.jsx)(Text, {
                id: labelId,
                weight: "semibold",
                children: header
              })
            }), showCloseButton && (0, import_jsx_runtime.jsx)(Box, {
              padding: 2,
              children: (0, import_jsx_runtime.jsx)(Button, {
                "aria-label": "Close dialog",
                disabled: !onClose,
                icon: CloseIcon,
                mode: "bleed",
                onClick: onClose,
                padding: 3
              })
            })]
          })
        }), (0, import_jsx_runtime.jsx)(DialogContent, {
          flex: 1,
          ref: setContentRef,
          tabIndex: -1,
          children
        }), footer && (0, import_jsx_runtime.jsx)(DialogFooter, {
          children: footer
        })]
      })
    })
  });
});
var Dialog = (0, import_react2.forwardRef)(function Dialog2(props, ref) {
  var _a2, _b2;
  const dialog = useDialog();
  const theme = useTheme();
  const {
    __unstable_autoFocus: autoFocus = true,
    __unstable_hideCloseButton: hideCloseButton = false,
    cardRadius: cardRadiusProp = 3,
    cardShadow = 4,
    children,
    contentRef,
    footer,
    header,
    id,
    onActivate,
    onClickOutside,
    onClose,
    onFocus,
    padding: paddingProp = 4,
    portal: portalProp,
    position: positionProp = dialog.position || "fixed",
    scheme,
    width: widthProp = 0,
    zOffset: zOffsetProp = dialog.zOffset || ((_a2 = theme.sanity.layer) == null ? void 0 : _a2.dialog.zOffset),
    ...restProps
  } = props;
  const portal = usePortal();
  const portalElement = portalProp ? ((_b2 = portal.elements) == null ? void 0 : _b2[portalProp]) || null : portal.element;
  const boundaryElement = useBoundaryElement().element;
  const cardRadius = useArrayProp(cardRadiusProp);
  const padding = useArrayProp(paddingProp);
  const position = useArrayProp(positionProp);
  const width = useArrayProp(widthProp);
  const zOffset = useArrayProp(zOffsetProp);
  const preDivRef = (0, import_react2.useRef)(null);
  const postDivRef = (0, import_react2.useRef)(null);
  const cardRef = (0, import_react2.useRef)(null);
  const focusedElementRef = (0, import_react2.useRef)(null);
  const handleFocus = (0, import_react2.useCallback)((event) => {
    onFocus == null ? void 0 : onFocus(event);
    const target = event.target;
    const cardElement = cardRef.current;
    if (cardElement && target === preDivRef.current) {
      focusLastDescendant(cardElement);
      return;
    }
    if (cardElement && target === postDivRef.current) {
      focusFirstDescendant(cardElement);
      return;
    }
    if (isHTMLElement(event.target)) {
      focusedElementRef.current = event.target;
    }
  }, [onFocus]);
  const labelId = "".concat(id, "_label");
  const rootClickTimeoutRef = (0, import_react2.useRef)();
  const handleRootClick = (0, import_react2.useCallback)(() => {
    if (rootClickTimeoutRef.current) {
      clearTimeout(rootClickTimeoutRef.current);
    }
    rootClickTimeoutRef.current = setTimeout(() => {
      const activeElement = document.activeElement;
      if (activeElement && !isTargetWithinScope(boundaryElement, portalElement, activeElement)) {
        const target = focusedElementRef.current;
        if (!target || !document.body.contains(target)) {
          const cardElement = cardRef.current;
          if (cardElement)
            focusFirstDescendant(cardElement);
          return;
        }
        target.focus();
      }
    }, 0);
  }, [boundaryElement, portalElement]);
  return (0, import_jsx_runtime.jsx)(Portal, {
    __unstable_name: portalProp,
    children: (0, import_jsx_runtime.jsxs)(Root$7, {
      ...restProps,
      $padding: padding,
      $position: position,
      "aria-labelledby": labelId,
      "aria-modal": true,
      "data-ui": "Dialog",
      id,
      onActivate,
      onClick: handleRootClick,
      onFocus: handleFocus,
      ref,
      role: "dialog",
      zOffset,
      children: [(0, import_jsx_runtime.jsx)("div", {
        ref: preDivRef,
        tabIndex: 0
      }), (0, import_jsx_runtime.jsx)(DialogCard, {
        __unstable_autoFocus: autoFocus,
        __unstable_hideCloseButton: hideCloseButton,
        contentRef,
        footer,
        header,
        id,
        onClickOutside,
        onClose,
        portal: portalProp,
        radius: cardRadius,
        ref: cardRef,
        scheme,
        shadow: cardShadow,
        width,
        children
      }), (0, import_jsx_runtime.jsx)("div", {
        ref: postDivRef,
        tabIndex: 0
      })]
    })
  });
});
var __freeze$a = Object.freeze;
var __defProp$a = Object.defineProperty;
var __template$a = (cooked, raw) => __freeze$a(__defProp$a(cooked, "raw", {
  value: __freeze$a(raw || cooked.slice())
}));
var _a$a;
var _b$5;
var Root$6 = styled_components_browser_esm_default.kbd(_a$a || (_a$a = __template$a(["\n  &:not([hidden]) {\n    display: block;\n  }\n  font: inherit;\n"])));
var Key = styled_components_browser_esm_default(KBD)(_b$5 || (_b$5 = __template$a(["\n  &:not([hidden]) {\n    display: block;\n  }\n"])));
var Hotkeys = (0, import_react2.forwardRef)(function Hotkeys2(props, ref) {
  const {
    fontSize: fontSize2,
    keys,
    padding,
    radius,
    space: spaceProp = 1,
    ...restProps
  } = props;
  const space = useArrayProp(spaceProp);
  if (!keys || keys.length === 0) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
  }
  return (0, import_jsx_runtime.jsx)(Root$6, {
    "data-ui": "Hotkeys",
    ...restProps,
    ref,
    children: (0, import_jsx_runtime.jsx)(Inline, {
      as: "span",
      space,
      children: keys.map((key2, i) => (0, import_jsx_runtime.jsx)(Key, {
        fontSize: fontSize2,
        padding,
        radius,
        children: key2
      }, i))
    })
  });
});
var key$2 = Symbol.for("@sanity/ui/context/menu");
globalScope[key$2] = globalScope[key$2] || (0, import_react2.createContext)(null);
var MenuContext = globalScope[key$2];
function _isFocusable(element) {
  return isHTMLAnchorElement(element) && element.getAttribute("data-disabled") !== "true" || isHTMLButtonElement(element) && !element.disabled;
}
function _getFocusableElements(elements) {
  return elements.filter(_isFocusable);
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e = el;
  while (e !== rootElement) {
    const parentElement = e.parentElement;
    if (!parentElement)
      return path;
    const children = Array.from(parentElement.childNodes);
    const index2 = children.indexOf(e);
    path.unshift(index2);
    if (parentElement === rootElement) {
      return path;
    }
    e = parentElement;
  }
  return path;
}
var EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  if (!rootElement)
    return;
  const map = /* @__PURE__ */ new WeakMap();
  for (const el of elements) {
    map.set(el, _getDOMPath(rootElement, el));
  }
  const _sort = (a, b) => {
    const _a2 = map.get(a) || EMPTY_PATH;
    const _b2 = map.get(b) || EMPTY_PATH;
    const len = Math.max(_a2.length, _b2.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a2[i] || -1;
      const bIndex = _b2[i] || -1;
      if (aIndex !== bIndex) {
        return aIndex - bIndex;
      }
    }
    return 0;
  };
  elements.sort(_sort);
}
function useMenuController(props) {
  const {
    onKeyDown,
    originElement,
    shouldFocus
  } = props;
  const elementsRef = (0, import_react2.useRef)([]);
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const [activeIndex, _setActiveIndex] = (0, import_react2.useState)(-1);
  const activeIndexRef = (0, import_react2.useRef)(activeIndex);
  const activeElement = elementsRef.current[activeIndex] || null;
  const mounted = Boolean(rootElement);
  const setActiveIndex = (0, import_react2.useCallback)((nextActiveIndex) => {
    _setActiveIndex(nextActiveIndex);
    activeIndexRef.current = nextActiveIndex;
  }, []);
  const mount = (0, import_react2.useCallback)((element, selected) => {
    if (!element)
      return () => void 0;
    if (elementsRef.current.indexOf(element) === -1) {
      elementsRef.current.push(element);
      _sortElements(rootElement, elementsRef.current);
    }
    if (selected) {
      const selectedIndex = elementsRef.current.indexOf(element);
      setActiveIndex(selectedIndex);
    }
    return () => {
      const idx = elementsRef.current.indexOf(element);
      if (idx > -1) {
        elementsRef.current.splice(idx, 1);
      }
    };
  }, [rootElement, setActiveIndex]);
  const handleKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "Tab") {
      if (originElement) {
        originElement.focus();
      }
      return;
    }
    if (event.key === "Home") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const el = focusableElements[0];
      if (!el)
        return;
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "End") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const el = focusableElements[focusableElements.length - 1];
      if (!el)
        return;
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const focusableLen = focusableElements.length;
      if (focusableLen === 0)
        return;
      const focusedElement = elementsRef.current[activeIndexRef.current];
      let focusedIndex = focusableElements.indexOf(focusedElement);
      focusedIndex = (focusedIndex - 1 + focusableLen) % focusableLen;
      const el = focusableElements[focusedIndex];
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const focusableLen = focusableElements.length;
      if (focusableLen === 0)
        return;
      const focusedElement = elementsRef.current[activeIndexRef.current];
      let focusedIndex = focusableElements.indexOf(focusedElement);
      focusedIndex = (focusedIndex + 1) % focusableLen;
      const el = focusableElements[focusedIndex];
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  }, [onKeyDown, originElement, setActiveIndex]);
  const handleItemMouseEnter = (0, import_react2.useCallback)((event) => {
    const element = event.currentTarget;
    const currentIndex = elementsRef.current.indexOf(element);
    setActiveIndex(currentIndex);
  }, [setActiveIndex]);
  const handleItemMouseLeave = (0, import_react2.useCallback)(() => {
    setActiveIndex(-2);
    rootElement == null ? void 0 : rootElement.focus();
  }, [setActiveIndex, rootElement]);
  (0, import_react2.useEffect)(() => {
    if (!mounted)
      return;
    const rafId = window.requestAnimationFrame(() => {
      const _activeIndex = activeIndexRef.current;
      if (_activeIndex === -1) {
        if (shouldFocus === "first") {
          const focusableElements = _getFocusableElements(elementsRef.current);
          const el = focusableElements[0];
          if (el) {
            const currentIndex = elementsRef.current.indexOf(el);
            setActiveIndex(currentIndex);
            activeIndexRef.current = currentIndex;
          }
        }
        if (shouldFocus === "last") {
          const focusableElements = _getFocusableElements(elementsRef.current);
          const el = focusableElements[focusableElements.length - 1];
          if (el) {
            const currentIndex = elementsRef.current.indexOf(el);
            setActiveIndex(currentIndex);
            activeIndexRef.current = currentIndex;
          }
        }
        return;
      }
      const element = elementsRef.current[_activeIndex] || null;
      element == null ? void 0 : element.focus();
    });
    return () => {
      window.cancelAnimationFrame(rafId);
    };
  }, [activeIndex, mounted, setActiveIndex, shouldFocus]);
  return {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount,
    rootElement,
    setRootElement
  };
}
var __freeze$9 = Object.freeze;
var __defProp$9 = Object.defineProperty;
var __template$9 = (cooked, raw) => __freeze$9(__defProp$9(cooked, "raw", {
  value: __freeze$9(raw || cooked.slice())
}));
var _a$9;
var Root$5 = styled_components_browser_esm_default(Box)(_a$9 || (_a$9 = __template$9(["\n  outline: none;\n  overflow: auto;\n"])));
var Menu = (0, import_react2.forwardRef)(function Menu2(props, ref) {
  const {
    children,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusFirst,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusLast,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemSelect,
    onKeyDown,
    originElement,
    padding = 1,
    registerElement,
    shouldFocus = props.focusFirst && "first" || props.focusLast && "last" || null,
    space = 1,
    ...restProps
  } = props;
  const forwardedRef = useForwardedRef(ref);
  const {
    isTopLayer
  } = useLayer();
  const {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount,
    rootElement,
    setRootElement
  } = useMenuController({
    onKeyDown,
    originElement,
    shouldFocus
  });
  const handleRefChange = (0, import_react2.useCallback)((el) => {
    setRootElement(el);
    forwardedRef.current = el;
  }, [forwardedRef, setRootElement]);
  (0, import_react2.useEffect)(() => {
    if (onItemSelect)
      onItemSelect(activeIndex);
  }, [activeIndex, onItemSelect]);
  useClickOutside((0, import_react2.useCallback)((event) => isTopLayer && onClickOutside && onClickOutside(event), [isTopLayer, onClickOutside]), [rootElement]);
  useGlobalKeyDown((0, import_react2.useCallback)((event) => {
    if (!isTopLayer)
      return;
    if (event.key === "Escape") {
      event.stopPropagation();
      if (onEscape)
        onEscape();
    }
  }, [isTopLayer, onEscape]));
  (0, import_react2.useEffect)(() => {
    if (!rootElement || !registerElement)
      return;
    return registerElement(rootElement);
  }, [registerElement, rootElement]);
  const value = (0, import_react2.useMemo)(() => ({
    version: 0,
    activeElement,
    activeIndex,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter: handleItemMouseEnter,
    onItemMouseLeave: handleItemMouseLeave,
    registerElement,
    // deprecated
    onMouseEnter: handleItemMouseEnter,
    onMouseLeave: handleItemMouseLeave
  }), [activeElement, activeIndex, mount, handleItemMouseEnter, handleItemMouseLeave, onClickOutside, onEscape, onItemClick, registerElement]);
  return (0, import_jsx_runtime.jsx)(MenuContext.Provider, {
    value,
    children: (0, import_jsx_runtime.jsx)(Root$5, {
      "data-ui": "Menu",
      ...restProps,
      onKeyDown: handleKeyDown,
      padding,
      ref: handleRefChange,
      role: "menu",
      tabIndex: -1,
      children: (0, import_jsx_runtime.jsx)(Stack, {
        space,
        children
      })
    })
  });
});
var MenuButton = (0, import_react2.forwardRef)(function MenuButton2(props, ref) {
  const {
    __unstable_disableRestoreFocusOnClose: disableRestoreFocusOnClose = false,
    boundaryElement: deprecated_boundaryElement,
    button: buttonProp,
    id,
    menu: menuProp,
    onClose,
    onOpen,
    placement: deprecated_placement,
    popoverScheme: deprecated_popoverScheme,
    portal: deprecated_portal = true,
    popover,
    popoverRadius: deprecated_popoverRadius,
    preventOverflow: deprecated_preventOverflow
  } = props;
  const [open, setOpen] = (0, import_react2.useState)(false);
  const [shouldFocus, setShouldFocus] = (0, import_react2.useState)(null);
  const [buttonElement, setButtonElement] = (0, import_react2.useState)(null);
  const [menuElements, setChildMenuElements] = (0, import_react2.useState)([]);
  const openRef = (0, import_react2.useRef)(open);
  (0, import_react2.useEffect)(() => {
    if (onOpen && open && !openRef.current) {
      onOpen();
    }
  }, [onOpen, open]);
  (0, import_react2.useEffect)(() => {
    if (onClose && !open && openRef.current) {
      onClose();
    }
  }, [onClose, open]);
  (0, import_react2.useEffect)(() => {
    openRef.current = open;
  }, [open]);
  const handleButtonClick = (0, import_react2.useCallback)(() => {
    setOpen((v) => !v);
    setShouldFocus(null);
  }, []);
  const handleButtonKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "ArrowDown" || event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      setOpen(true);
      setShouldFocus("first");
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      setOpen(true);
      setShouldFocus("last");
      return;
    }
  }, []);
  const handleMenuClickOutside = (0, import_react2.useCallback)((event) => {
    const target = event.target;
    if (!(target instanceof Node)) {
      return;
    }
    if (buttonElement && (target === buttonElement || buttonElement.contains(target))) {
      return;
    }
    for (const el of menuElements) {
      if (target === el || el.contains(target)) {
        return;
      }
    }
    setOpen(false);
  }, [buttonElement, menuElements]);
  const handleMenuEscape = (0, import_react2.useCallback)(() => {
    setOpen(false);
    if (disableRestoreFocusOnClose)
      return;
    if (buttonElement)
      buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]);
  const handleBlur = (0, import_react2.useCallback)((event) => {
    const target = event.relatedTarget;
    if (!(target instanceof Node)) {
      return;
    }
    for (const el of menuElements) {
      if (el === target || el.contains(target)) {
        return;
      }
    }
    setOpen(false);
  }, [menuElements]);
  const handleItemClick = (0, import_react2.useCallback)(() => {
    setOpen(false);
    if (disableRestoreFocusOnClose)
      return;
    if (buttonElement)
      buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]);
  const registerElement = (0, import_react2.useCallback)((el) => {
    setChildMenuElements((els) => els.concat([el]));
    return () => {
      setChildMenuElements((els) => {
        return els.filter((_el) => _el !== el);
      });
    };
  }, []);
  const menuProps = (0, import_react2.useMemo)(() => ({
    "aria-labelledby": id,
    onBlurCapture: handleBlur,
    onClickOutside: handleMenuClickOutside,
    onEscape: handleMenuEscape,
    onItemClick: handleItemClick,
    originElement: buttonElement,
    registerElement,
    shouldFocus
  }), [buttonElement, handleMenuClickOutside, handleMenuEscape, handleItemClick, id, handleBlur, registerElement, shouldFocus]);
  const menu = (0, import_react_is.isElement)(menuProp) ? (0, import_react2.cloneElement)(menuProp, menuProps) : null;
  const setButtonRef = (0, import_react2.useCallback)((el) => {
    if (typeof ref === "function") {
      ref(el);
    } else if (ref) {
      ref.current = el;
    }
    setButtonElement(el);
  }, [ref]);
  const button = (0, import_react2.useMemo)(() => (0, import_react_is.isElement)(buttonProp) ? (0, import_react2.cloneElement)(buttonProp, {
    "data-ui": "MenuButton",
    id,
    onClick: handleButtonClick,
    onKeyDown: handleButtonKeyDown,
    "aria-haspopup": true,
    "aria-expanded": open,
    ref: setButtonRef,
    selected: open
  }) : null, [buttonProp, handleButtonClick, handleButtonKeyDown, id, open, setButtonRef]);
  const popoverProps = (0, import_react2.useMemo)(() => ({
    boundaryElement: deprecated_boundaryElement,
    overflow: "auto",
    placement: deprecated_placement,
    portal: deprecated_portal,
    preventOverflow: deprecated_preventOverflow,
    radius: deprecated_popoverRadius,
    scheme: deprecated_popoverScheme,
    ...popover || {}
  }), [deprecated_boundaryElement, deprecated_placement, deprecated_popoverRadius, deprecated_popoverScheme, deprecated_portal, deprecated_preventOverflow, popover]);
  return (0, import_jsx_runtime.jsx)(Popover, {
    "data-ui": "MenuButton__popover",
    ...popoverProps,
    content: menu,
    open,
    children: button || (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {})
  });
});
var __freeze$8 = Object.freeze;
var __defProp$8 = Object.defineProperty;
var __template$8 = (cooked, raw) => __freeze$8(__defProp$8(cooked, "raw", {
  value: __freeze$8(raw || cooked.slice())
}));
var _a$8;
var MenuDivider = styled_components_browser_esm_default.hr(_a$8 || (_a$8 = __template$8(["\n  height: 1px;\n  border: 0;\n  background: var(--card-hairline-soft-color);\n  margin: 0;\n"])));
var __freeze$7 = Object.freeze;
var __defProp$7 = Object.defineProperty;
var __template$7 = (cooked, raw) => __freeze$7(__defProp$7(cooked, "raw", {
  value: __freeze$7(raw || cooked.slice())
}));
var _a$7;
var _b$4;
function selectableBaseStyle() {
  return Ae(_a$7 || (_a$7 = __template$7(["\n    background-color: inherit;\n    color: inherit;\n\n    &[data-as='button'] {\n      -webkit-font-smoothing: inherit;\n      appearance: none;\n      outline: none;\n      font: inherit;\n      text-align: inherit;\n      border: 0;\n      width: -webkit-fill-available;\n      width: stretch;\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      text-decoration: none;\n    }\n  "])));
}
function selectableColorStyle(props) {
  var _a2, _b2;
  const {
    $tone,
    theme
  } = props;
  const {
    base,
    muted,
    selectable
  } = theme.sanity.color;
  const tone = selectable ? selectable[$tone] || selectable.default : muted[$tone] || muted.default;
  return Ae(_b$4 || (_b$4 = __template$7(["\n    ", "\n\n    background-color: var(--card-bg-color);\n    color: var(--card-fg-color);\n    outline: none;\n\n    /* &:is(button) */\n    &[data-as='button'] {\n      &:disabled {\n        ", "\n      }\n\n      &:not(:disabled) {\n        &[aria-pressed='true'] {\n          ", "\n        }\n\n        &[data-selected],\n        &[aria-selected='true'] > & {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n      }\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      &[data-disabled] {\n        ", "\n      }\n\n      &:not([data-disabled]) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n      }\n    }\n\n    ", "\n  "])), _colorVarsStyle(base, tone.enabled), _colorVarsStyle(base, tone.disabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.selected), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.disabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.selected), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.pressed), (_b2 = (_a2 = theme.sanity.styles) == null ? void 0 : _a2.card) == null ? void 0 : _b2.root);
}
var Selectable = styled_components_browser_esm_default(Box)(responsiveRadiusStyle, selectableBaseStyle, selectableColorStyle);
function useMenu() {
  const value = (0, import_react2.useContext)(MenuContext);
  if (!value) {
    throw new Error("useMenu(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("useMenu(): the context value is not compatible");
  }
  return value;
}
var MenuItem = (0, import_react2.forwardRef)(function MenuItem2(props, forwardedRef) {
  const {
    as = "button",
    children,
    disabled,
    fontSize: fontSize2 = 2,
    hotkeys,
    icon,
    iconRight,
    onClick,
    padding = 3,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    pressed,
    radius = 2,
    selected: selectedProp,
    space = 3,
    text,
    tone = "default",
    ...restProps
  } = props;
  const menu = useMenu();
  const {
    activeElement,
    mount,
    onItemClick,
    onItemMouseEnter = menu.onMouseEnter,
    onItemMouseLeave = menu.onMouseLeave
  } = menu;
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const active = Boolean(activeElement) && activeElement === rootElement;
  (0, import_react2.useEffect)(() => mount(rootElement, selectedProp), [mount, rootElement, selectedProp]);
  const ref = useForwardedRef(forwardedRef);
  const handleClick = (0, import_react2.useCallback)((event) => {
    if (disabled)
      return;
    if (onClick)
      onClick(event);
    if (onItemClick)
      onItemClick();
  }, [disabled, onClick, onItemClick]);
  const paddingProps = (0, import_react2.useMemo)(() => ({
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft
  }), [padding, paddingX, paddingY, paddingTop, paddingRight, paddingBottom, paddingLeft]);
  const setRef = (0, import_react2.useCallback)((el) => {
    ref.current = el;
    setRootElement(el);
  }, [ref]);
  return (0, import_jsx_runtime.jsxs)(Selectable, {
    "data-ui": "MenuItem",
    ...restProps,
    "aria-pressed": as === "button" && pressed,
    "data-pressed": as !== "button" && pressed ? "" : void 0,
    "data-selected": active ? "" : void 0,
    "data-disabled": disabled ? "" : void 0,
    forwardedAs: as,
    $radius: useArrayProp(radius),
    $padding: useArrayProp(0),
    $tone: tone,
    disabled,
    onClick: handleClick,
    onMouseEnter: onItemMouseEnter,
    onMouseLeave: onItemMouseLeave,
    ref: setRef,
    role: "menuitem",
    tabIndex: -1,
    type: as === "button" ? "button" : void 0,
    children: [(icon || text || iconRight) && (0, import_jsx_runtime.jsx)(Box, {
      as: "span",
      ...paddingProps,
      children: (0, import_jsx_runtime.jsxs)(Flex, {
        as: "span",
        children: [icon && (0, import_jsx_runtime.jsxs)(Text, {
          size: fontSize2,
          children: [(0, import_react2.isValidElement)(icon) && icon, (0, import_react_is.isValidElementType)(icon) && (0, import_react2.createElement)(icon)]
        }), text && (0, import_jsx_runtime.jsx)(Box, {
          flex: 1,
          marginLeft: icon ? space : void 0,
          marginRight: iconRight ? space : void 0,
          children: (0, import_jsx_runtime.jsx)(Text, {
            size: fontSize2,
            textOverflow: "ellipsis",
            children: text
          })
        }), hotkeys && (0, import_jsx_runtime.jsx)(Box, {
          marginLeft: space,
          style: {
            marginTop: -4,
            marginBottom: -4
          },
          children: (0, import_jsx_runtime.jsx)(Hotkeys, {
            fontSize: fontSize2,
            keys: hotkeys
          })
        }), iconRight && (0, import_jsx_runtime.jsxs)(Text, {
          size: fontSize2,
          children: [(0, import_react2.isValidElement)(iconRight) && iconRight, (0, import_react_is.isValidElementType)(iconRight) && (0, import_react2.createElement)(iconRight)]
        })]
      })
    }), children && (0, import_jsx_runtime.jsx)(Box, {
      as: "span",
      ...paddingProps,
      children
    })]
  });
});
var __freeze$6 = Object.freeze;
var __defProp$6 = Object.defineProperty;
var __template$6 = (cooked, raw) => __freeze$6(__defProp$6(cooked, "raw", {
  value: __freeze$6(raw || cooked.slice())
}));
var _a$6;
var _b$3;
var _c$1;
var _d;
var keyframe = We(_a$6 || (_a$6 = __template$6(["\n  0% {\n    background-position: 100%;\n  }\n  100% {\n    background-position: -100%;\n  }\n"])));
var animation = Ae(_b$3 || (_b$3 = __template$6(["\n  background-image: linear-gradient(\n    to right,\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-to),\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-from)\n  );\n  background-position: 100%;\n  background-size: 200% 100%;\n  background-attachment: fixed;\n  animation-name: ", ";\n  animation-timing-function: ease-in-out;\n  animation-iteration-count: infinite;\n  animation-duration: 2000ms;\n"])), keyframe);
var skeletonStyle = Ae(_d || (_d = __template$6(["\n  opacity: ", ";\n  transition: opacity 200ms ease-in;\n\n  @media screen and (prefers-reduced-motion: no-preference) {\n    ", "\n  }\n\n  @media screen and (prefers-reduced-motion: reduce) {\n    background-color: var(--card-skeleton-color-from);\n  }\n"])), (_ref25) => {
  let {
    $visible
  } = _ref25;
  return $visible ? 1 : 0;
}, (_ref26) => {
  let {
    $animated
  } = _ref26;
  return $animated ? animation : Ae(_c$1 || (_c$1 = __template$6(["\n            background-color: var(--card-skeleton-color-from);\n          "])));
});
var Root$4 = styled_components_browser_esm_default(Box)(responsiveRadiusStyle, skeletonStyle);
var Skeleton = (0, import_react2.forwardRef)(function Skeleton2(props, ref) {
  const {
    animated = false,
    delay,
    radius,
    ...restProps
  } = props;
  const [visible, setVisible] = (0, import_react2.useState)(delay ? false : true);
  (0, import_react2.useEffect)(() => {
    if (!delay) {
      return setVisible(true);
    }
    const timeout = setTimeout(() => {
      setVisible(true);
    }, delay);
    return () => {
      clearTimeout(timeout);
    };
  }, [delay]);
  return (0, import_jsx_runtime.jsx)(Root$4, {
    ...restProps,
    $animated: animated,
    $radius: useArrayProp(radius),
    $visible: visible,
    ref
  });
});
var Root$3 = styled_components_browser_esm_default(Skeleton)((_ref27) => {
  let {
    $size,
    $style,
    theme
  } = _ref27;
  const {
    media
  } = theme.sanity;
  const font = theme.sanity.fonts[$style];
  const styles = _responsive(media, $size, (sizeIndex) => {
    const fontSize2 = font.sizes[sizeIndex];
    const capHeight = fontSize2.lineHeight - fontSize2.ascenderHeight - fontSize2.descenderHeight;
    return {
      height: capHeight
    };
  });
  return styles;
});
var TextSkeleton = (0, import_react2.forwardRef)(function TextSkeleton2(props, ref) {
  const {
    size: size3 = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size3);
  return (0, import_jsx_runtime.jsx)(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "text"
  });
});
var LabelSkeleton = (0, import_react2.forwardRef)(function TextSkeleton3(props, ref) {
  const {
    size: size3 = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size3);
  return (0, import_jsx_runtime.jsx)(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "label"
  });
});
var HeadingSkeleton = (0, import_react2.forwardRef)(function TextSkeleton4(props, ref) {
  const {
    size: size3 = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size3);
  return (0, import_jsx_runtime.jsx)(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "heading"
  });
});
var CodeSkeleton = (0, import_react2.forwardRef)(function TextSkeleton5(props, ref) {
  const {
    size: size3 = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size3);
  return (0, import_jsx_runtime.jsx)(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "code"
  });
});
var __freeze$5 = Object.freeze;
var __defProp$5 = Object.defineProperty;
var __template$5 = (cooked, raw) => __freeze$5(__defProp$5(cooked, "raw", {
  value: __freeze$5(raw || cooked.slice())
}));
var _a$5;
var CustomButton = styled_components_browser_esm_default(Button)(_a$5 || (_a$5 = __template$5(["\n  max-width: 100%;\n"])));
var Tab = (0, import_react2.forwardRef)(function Tab2(props, forwardedRef) {
  const {
    icon,
    id,
    focused,
    fontSize: fontSize2,
    label,
    onClick,
    onFocus,
    padding = 2,
    selected,
    ...restProps
  } = props;
  const elementRef = (0, import_react2.useRef)(null);
  const focusedRef = (0, import_react2.useRef)(false);
  const handleBlur = (0, import_react2.useCallback)(() => {
    focusedRef.current = false;
  }, []);
  const handleFocus = (0, import_react2.useCallback)((event) => {
    focusedRef.current = true;
    if (onFocus)
      onFocus(event);
  }, [onFocus]);
  const ref = useForwardedRef(forwardedRef);
  (0, import_react2.useEffect)(() => {
    if (focused && !focusedRef.current) {
      if (elementRef.current)
        elementRef.current.focus();
      focusedRef.current = true;
    }
  }, [focused]);
  const setRef = (el) => {
    elementRef.current = el;
    ref.current = el;
  };
  return (0, import_jsx_runtime.jsx)(CustomButton, {
    "data-ui": "Tab",
    ...restProps,
    "aria-selected": selected ? "true" : "false",
    fontSize: fontSize2,
    icon,
    id,
    mode: "bleed",
    onClick,
    onBlur: handleBlur,
    onFocus: handleFocus,
    padding,
    ref: setRef,
    role: "tab",
    selected,
    tabIndex: selected ? 0 : -1,
    text: label,
    type: "button"
  });
});
var __freeze$4 = Object.freeze;
var __defProp$4 = Object.defineProperty;
var __template$4 = (cooked, raw) => __freeze$4(__defProp$4(cooked, "raw", {
  value: __freeze$4(raw || cooked.slice())
}));
var _a$4;
function _isReactElement(node) {
  return Boolean(node);
}
var CustomInline = styled_components_browser_esm_default(Inline)(_a$4 || (_a$4 = __template$4(["\n  & > div {\n    display: inline-block;\n    vertical-align: middle;\n    max-width: 100%;\n    box-sizing: border-box;\n  }\n"])));
var TabList = (0, import_react2.forwardRef)(function TabList2(props, ref) {
  const {
    children: childrenProp,
    ...restProps
  } = props;
  const [focusedIndex, setFocusedIndex] = (0, import_react2.useState)(-1);
  const children = (0, import_react2.useMemo)(() => childrenProp.filter(_isReactElement), [childrenProp]);
  const tabs = children.map((child, childIndex) => (0, import_react2.cloneElement)(child, {
    focused: focusedIndex === childIndex,
    key: childIndex,
    onFocus: () => handleTabFocus(childIndex)
  }));
  const numTabs = tabs.length;
  const handleTabFocus = (0, import_react2.useCallback)((tabIdx) => {
    setFocusedIndex(tabIdx);
  }, []);
  const handleKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "ArrowLeft") {
      setFocusedIndex((prevIndex) => (prevIndex + numTabs - 1) % numTabs);
    }
    if (event.key === "ArrowRight") {
      setFocusedIndex((prevIndex) => (prevIndex + 1) % numTabs);
    }
  }, [numTabs]);
  return (0, import_jsx_runtime.jsx)(CustomInline, {
    "data-ui": "TabList",
    ...restProps,
    onKeyDown: handleKeyDown,
    ref,
    role: "tablist",
    children: tabs
  });
});
var TabPanel = (0, import_react2.forwardRef)(function TabPanel2(props, ref) {
  const {
    flex,
    ...restProps
  } = props;
  return (0, import_jsx_runtime.jsx)(Box, {
    "data-ui": "TabPanel",
    ...restProps,
    flex,
    ref,
    role: "tabpanel",
    tabIndex: props.tabIndex === void 0 ? 0 : props.tabIndex,
    children: props.children
  });
});
var __freeze$3 = Object.freeze;
var __defProp$3 = Object.defineProperty;
var __template$3 = (cooked, raw) => __freeze$3(__defProp$3(cooked, "raw", {
  value: __freeze$3(raw || cooked.slice())
}));
var _a$3;
var _b$2;
var Root$2 = styled_components_browser_esm_default(Card)(_a$3 || (_a$3 = __template$3(["\n  pointer-events: all;\n"])));
var TextBox = styled_components_browser_esm_default(Flex)(_b$2 || (_b$2 = __template$3(["\n  overflow-x: auto;\n"])));
var key$1 = Symbol.for("@sanity/ui/context/toast");
globalScope[key$1] = globalScope[key$1] || (0, import_react2.createContext)(null);
var ToastContext = globalScope[key$1];
var __freeze$2 = Object.freeze;
var __defProp$2 = Object.defineProperty;
var __template$2 = (cooked, raw) => __freeze$2(__defProp$2(cooked, "raw", {
  value: __freeze$2(raw || cooked.slice())
}));
var _a$2;
var _b$1;
var Root$1 = styled_components_browser_esm_default(Layer)(_a$2 || (_a$2 = __template$2(["\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  pointer-events: none;\n"])));
var ToastContainer = styled_components_browser_esm_default.div(_b$1 || (_b$1 = __template$2(["\n  box-sizing: border-box;\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  max-width: 420px;\n  width: 100%;\n"])));
function _findPrevItemElement(state, itemElements, focusedElement) {
  var _a2;
  const idx = itemElements.indexOf(focusedElement);
  const els = itemElements.slice(0, idx);
  const len = els.length;
  for (let i = len - 1; i >= 0; i -= 1) {
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey) {
      continue;
    }
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = true;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!((_a2 = state[k]) == null ? void 0 : _a2.expanded)) {
        expanded = false;
        break;
      }
    }
    if (expanded) {
      return els[i];
    }
  }
  return null;
}
function _findNextItemElement(state, itemElements, focusedElement) {
  var _a2;
  const idx = itemElements.indexOf(focusedElement);
  const els = itemElements.slice(idx);
  const len = itemElements.length;
  for (let i = 1; i < len; i += 1) {
    if (!els[i]) {
      continue;
    }
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey) {
      continue;
    }
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = true;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!((_a2 = state[k]) == null ? void 0 : _a2.expanded)) {
        expanded = false;
        break;
      }
    }
    if (expanded) {
      return els[i];
    }
  }
  return null;
}
function _focusItemElement(el) {
  if (el.getAttribute("role") === "treeitem") {
    el.focus();
  }
  if (el.getAttribute("role") === "none") {
    const firstChild = el.firstChild;
    if (firstChild && firstChild instanceof HTMLElement) {
      firstChild.focus();
    }
  }
}
var key = Symbol.for("@sanity/ui/context/tree");
globalScope[key] = globalScope[key] || (0, import_react2.createContext)(null);
var TreeContext = globalScope[key];
var Tree = (0, import_react2.memo)((0, import_react2.forwardRef)(function Tree2(props, ref) {
  const {
    children,
    space = 1,
    onFocus,
    ...restProps
  } = props;
  const forwardedRef = useForwardedRef(ref);
  const [focusedElement, setFocusedElement] = (0, import_react2.useState)(null);
  const focusedElementRef = (0, import_react2.useRef)(focusedElement);
  const path = (0, import_react2.useMemo)(() => [], []);
  const [itemElements, setItemElements] = (0, import_react2.useState)([]);
  const [state, setState] = (0, import_react2.useState)({});
  const stateRef = (0, import_react2.useRef)(state);
  (0, import_react2.useEffect)(() => {
    focusedElementRef.current = focusedElement;
  }, [focusedElement]);
  (0, import_react2.useEffect)(() => {
    stateRef.current = state;
  }, [state]);
  const registerItem = (0, import_react2.useCallback)((element, path2, expanded, selected) => {
    setState((s) => ({
      ...s,
      [path2]: {
        element,
        expanded
      }
    }));
    if (selected) {
      setFocusedElement(element);
    }
    return () => {
      setState((s) => {
        const newState = {
          ...s
        };
        delete newState[path2];
        return newState;
      });
    };
  }, []);
  const setExpanded = (0, import_react2.useCallback)((path2, expanded) => {
    setState((s) => {
      const itemState = s[path2];
      if (!itemState)
        return s;
      return {
        ...s,
        [path2]: {
          ...itemState,
          expanded
        }
      };
    });
  }, []);
  const contextValue = (0, import_react2.useMemo)(() => ({
    version: 0,
    focusedElement: focusedElement || itemElements[0] || null,
    level: 0,
    path,
    registerItem,
    setExpanded,
    setFocusedElement,
    space,
    state
  }), [focusedElement, itemElements, path, registerItem, setExpanded, space, state]);
  const handleKeyDown = (0, import_react2.useCallback)((event) => {
    var _a2;
    if (!focusedElementRef.current)
      return;
    if (event.key === "ArrowDown") {
      event.preventDefault();
      const nextEl = _findNextItemElement(stateRef.current, itemElements, focusedElementRef.current);
      if (nextEl) {
        _focusItemElement(nextEl);
        setFocusedElement(nextEl);
      }
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      const prevEl = _findPrevItemElement(stateRef.current, itemElements, focusedElementRef.current);
      if (prevEl) {
        _focusItemElement(prevEl);
        setFocusedElement(prevEl);
      }
      return;
    }
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      const itemKey = focusedElementRef.current.getAttribute("data-tree-key");
      if (!itemKey)
        return;
      const itemState = stateRef.current[itemKey];
      if (!itemState)
        return;
      if (itemState.expanded) {
        setState((s) => {
          const itemState2 = s[itemKey];
          if (!itemState2)
            return s;
          return {
            ...s,
            [itemKey]: {
              ...itemState2,
              expanded: false
            }
          };
        });
      } else {
        const itemPath = itemKey.split("/");
        itemPath.pop();
        const parentKey = itemPath.join("/");
        const parentState = parentKey && stateRef.current[parentKey];
        if (parentState) {
          parentState.element.focus();
          setFocusedElement(parentState.element);
        }
      }
      return;
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      const focusedKey = focusedElementRef.current.getAttribute("data-tree-key");
      if (!focusedKey)
        return;
      if (!((_a2 = stateRef.current[focusedKey]) == null ? void 0 : _a2.expanded)) {
        setState((s) => {
          const itemState = s[focusedKey];
          if (!itemState)
            return s;
          return {
            ...s,
            [focusedKey]: {
              ...itemState,
              expanded: true
            }
          };
        });
      }
      return;
    }
  }, [itemElements]);
  const handleFocus = (0, import_react2.useCallback)((event) => {
    setFocusedElement(event.target);
    onFocus == null ? void 0 : onFocus(event);
  }, [onFocus]);
  (0, import_react2.useEffect)(() => {
    if (!forwardedRef.current)
      return;
    const _itemElements = Array.from(forwardedRef.current.querySelectorAll('[data-ui="TreeItem"]'));
    setItemElements(_itemElements);
  }, [children, forwardedRef]);
  return (0, import_jsx_runtime.jsx)(TreeContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime.jsx)(Stack, {
      as: "ul",
      "data-ui": "Tree",
      ...restProps,
      onFocus: handleFocus,
      onKeyDown: handleKeyDown,
      ref: forwardedRef,
      role: "tree",
      space,
      children
    })
  });
}));
Tree.displayName = "Tree";
var __freeze$1 = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", {
  value: __freeze$1(raw || cooked.slice())
}));
var _a$1;
var _b;
var _c;
function treeItemRootStyle() {
  return Ae(_a$1 || (_a$1 = __template$1(["\n    &[role='none'] > [role='treeitem'] {\n      outline: none;\n      cursor: default;\n      border-radius: 3px;\n\n      &:focus {\n        position: relative;\n      }\n    }\n\n    &[role='treeitem'] {\n      outline: none;\n\n      & > div {\n        cursor: default;\n        border-radius: 3px;\n      }\n\n      &:focus > div {\n        position: relative;\n      }\n    }\n  "])));
}
function treeItemRootColorStyle(props) {
  const {
    theme
  } = props;
  const $tone = "default";
  const {
    base,
    muted,
    selectable
  } = theme.sanity.color;
  const tone = selectable ? selectable[$tone] || selectable.default : muted[$tone] || muted.default;
  return Ae(_b || (_b = __template$1([`
    /* <div role="none"><a data-ui="TreeItem__box" role="treeitem" tabIndex="0"></div> */
    &[role='none'] {
      & > [role='treeitem'] {
        `, "\n\n        background-color: var(--card-bg-color);\n        color: var(--treeitem-fg-color);\n      }\n\n      &[data-selected] > [role='treeitem'] {\n        ", "\n      }\n\n      @media (hover: hover) {\n        &:not([data-selected]) > [role='treeitem']:not(:focus):hover {\n          ", "\n        }\n\n        & > [role='treeitem']:focus {\n          ", `
        }
      }
    }

    /* <div role="treeitem" tabIndex="0"><div data-ui="TreeItem__box"></div> */
    &[role='treeitem'] {
      & > [data-ui='TreeItem__box'] {
        `, "\n\n        background-color: var(--card-bg-color);\n        color: var(--card-fg-color);\n      }\n\n      &[data-selected] > [data-ui='TreeItem__box'] {\n        ", "\n      }\n\n      @media (hover: hover) {\n        &:not([data-selected]):not(:focus) > [data-ui='TreeItem__box']:hover {\n          ", "\n        }\n\n        &:focus > [data-ui='TreeItem__box'] {\n          ", "\n        }\n      }\n    }\n  "])), _colorVarsStyle(base, tone.enabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.selected), _colorVarsStyle(base, tone.enabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.selected));
}
function treeItemBoxStyle(props) {
  const {
    $level,
    theme
  } = props;
  const {
    space
  } = theme.sanity;
  return Ae(_c || (_c = __template$1(["\n    padding-left: ", ";\n\n    &[data-as='a'] {\n      text-decoration: none;\n    }\n  "])), rem(space[2] * $level));
}
function useTree() {
  const tree = (0, import_react2.useContext)(TreeContext);
  if (!tree) {
    throw new Error("Tree: missing context value");
  }
  return tree;
}
var TreeGroup = (0, import_react2.memo)(function TreeGroup2(props) {
  const {
    children,
    expanded = false,
    ...restProps
  } = props;
  const tree = useTree();
  return (0, import_jsx_runtime.jsx)(Stack, {
    as: "ul",
    "data-ui": "TreeGroup",
    ...restProps,
    hidden: !expanded,
    marginTop: tree.space,
    role: "group",
    space: tree.space,
    children
  });
});
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a;
var Root = (0, import_react2.memo)(styled_components_browser_esm_default.li(treeItemRootStyle, treeItemRootColorStyle));
var TreeItemBox = styled_components_browser_esm_default(Box).attrs({
  forwardedAs: "a"
})(treeItemBoxStyle);
var ToggleArrowText = styled_components_browser_esm_default(Text)(_a || (_a = __template(["\n  & > svg {\n    transition: transform 100ms;\n  }\n"])));
var TreeItem = (0, import_react2.memo)(function TreeItem2(props) {
  const {
    children,
    expanded: expandedProp = false,
    fontSize: fontSize2,
    href,
    icon,
    id: idProp,
    linkAs,
    muted,
    onClick,
    padding = 3,
    selected = false,
    space = 2,
    text,
    weight,
    ...restProps
  } = props;
  const rootRef = (0, import_react2.useRef)(null);
  const treeitemRef = (0, import_react2.useRef)(null);
  const tree = useTree();
  const {
    path,
    registerItem,
    setExpanded,
    setFocusedElement
  } = tree;
  const _id = (0, import_react2.useId)();
  const id = idProp || _id;
  const itemPath = (0, import_react2.useMemo)(() => path.concat([id || ""]), [id, path]);
  const itemKey = itemPath.join("/");
  const itemState = tree.state[itemKey];
  const focused = tree.focusedElement === rootRef.current;
  const expanded = (itemState == null ? void 0 : itemState.expanded) === void 0 ? expandedProp : (itemState == null ? void 0 : itemState.expanded) || false;
  const tabIndex = tree.focusedElement && tree.focusedElement === rootRef.current ? 0 : -1;
  const contextValue = (0, import_react2.useMemo)(() => ({
    ...tree,
    level: tree.level + 1,
    path: itemPath
  }), [itemPath, tree]);
  const handleClick = (0, import_react2.useCallback)((event) => {
    if (onClick)
      onClick(event);
    const target = event.target;
    if (target instanceof HTMLElement && (target.getAttribute("data-ui") === "TreeItem" || target.closest('[data-ui="TreeItem__box"]'))) {
      event.stopPropagation();
      setExpanded(itemKey, !expanded);
      setFocusedElement(rootRef.current);
    }
  }, [expanded, itemKey, onClick, setExpanded, setFocusedElement]);
  const handleKeyDown = (0, import_react2.useCallback)((event) => {
    if (focused && event.key === "Enter") {
      const el = treeitemRef.current || rootRef.current;
      el == null ? void 0 : el.click();
    }
  }, [focused]);
  (0, import_react2.useEffect)(() => {
    if (!rootRef.current)
      return;
    return registerItem(rootRef.current, itemPath.join("/"), expanded, selected);
  }, [expanded, itemPath, registerItem, selected]);
  const content = (0, import_jsx_runtime.jsxs)(Flex, {
    padding,
    children: [(0, import_jsx_runtime.jsxs)(Box, {
      marginRight: space,
      style: {
        visibility: icon || children ? "visible" : "hidden",
        pointerEvents: "none"
      },
      children: [icon && (0, import_jsx_runtime.jsx)(Text, {
        muted,
        size: fontSize2,
        weight,
        children: (0, import_react2.createElement)(icon)
      }), !icon && (0, import_jsx_runtime.jsx)(ToggleArrowText, {
        muted,
        size: fontSize2,
        weight,
        children: (0, import_jsx_runtime.jsx)(ToggleArrowRightIcon, {
          style: {
            transform: expanded ? "rotate(90deg)" : void 0
          }
        })
      })]
    }), (0, import_jsx_runtime.jsx)(Box, {
      flex: 1,
      children: (0, import_jsx_runtime.jsx)(Text, {
        muted,
        size: fontSize2,
        textOverflow: "ellipsis",
        weight,
        children: text
      })
    })]
  });
  if (href) {
    return (0, import_jsx_runtime.jsxs)(Root, {
      "data-selected": selected ? "" : void 0,
      "data-tree-id": id,
      "data-tree-key": itemKey,
      "data-ui": "TreeItem",
      ...restProps,
      onClick: handleClick,
      ref: rootRef,
      role: "none",
      children: [(0, import_jsx_runtime.jsx)(TreeItemBox, {
        $level: tree.level,
        "aria-expanded": expanded,
        as: linkAs,
        "data-ui": "TreeItem__box",
        href,
        ref: treeitemRef,
        role: "treeitem",
        tabIndex,
        children: content
      }), (0, import_jsx_runtime.jsx)(TreeContext.Provider, {
        value: contextValue,
        children: children && (0, import_jsx_runtime.jsx)(TreeGroup, {
          hidden: !expanded,
          children
        })
      })]
    });
  }
  return (0, import_jsx_runtime.jsxs)(Root, {
    "data-selected": selected ? "" : void 0,
    "data-ui": "TreeItem",
    "data-tree-id": id,
    "data-tree-key": itemKey,
    ...restProps,
    "aria-expanded": expanded,
    onClick: handleClick,
    onKeyDown: handleKeyDown,
    ref: rootRef,
    role: "treeitem",
    tabIndex,
    children: [(0, import_jsx_runtime.jsx)(TreeItemBox, {
      $level: tree.level,
      as: "div",
      "data-ui": "TreeItem__box",
      children: content
    }), (0, import_jsx_runtime.jsx)(TreeContext.Provider, {
      value: contextValue,
      children: children && (0, import_jsx_runtime.jsx)(TreeGroup, {
        expanded,
        children
      })
    })]
  });
});

// node_modules/sanity-plugin-markdown/lib/_chunks/plugin-ca10aa4c.js
var _templateObject;
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
}
var MarkdownInputStyles = styled_components_browser_esm_default(Box)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  & .CodeMirror.CodeMirror {\n    color: ", ";\n    border-color: ", ";\n    background-color: inherit;\n  }\n\n  & .cm-s-easymde .CodeMirror-cursor {\n    border-color: ", ";\n  }\n\n  & .editor-toolbar,\n  .editor-preview-side {\n    border-color: ", ";\n  }\n\n  & .CodeMirror-focused .CodeMirror-selected.CodeMirror-selected.CodeMirror-selected {\n    background-color: ", ";\n  }\n\n  & .CodeMirror-selected.CodeMirror-selected.CodeMirror-selected {\n    background-color: ", ";\n  }\n\n  & .editor-toolbar > * {\n    color: ", ";\n  }\n\n  & .editor-toolbar > .active,\n  .editor-toolbar > button:hover,\n  .editor-preview pre,\n  .cm-s-easymde .cm-comment {\n    background-color: ", ";\n  }\n\n  & .editor-preview {\n    background-color: ", ";\n\n    & h1,\n    h2,\n    h3,\n    h4,\n    h5,\n    h6 {\n      font-size: revert;\n    }\n\n    & ul,\n    li {\n      list-style: revert;\n      padding: revert;\n    }\n\n    & a {\n      text-decoration: revert;\n    }\n  }\n"])), (_ref) => {
  let {
    theme
  } = _ref;
  return theme.sanity.color.card.enabled.fg;
}, (_ref2) => {
  let {
    theme
  } = _ref2;
  return theme.sanity.color.card.enabled.border;
}, (_ref3) => {
  let {
    theme
  } = _ref3;
  return theme.sanity.color.card.enabled.fg;
}, (_ref4) => {
  let {
    theme
  } = _ref4;
  return theme.sanity.color.card.enabled.border;
}, (_ref5) => {
  let {
    theme
  } = _ref5;
  return theme.sanity.color.selectable.primary.hovered.bg;
}, (_ref6) => {
  let {
    theme
  } = _ref6;
  return theme.sanity.color.card.enabled.bg;
}, (_ref7) => {
  let {
    theme
  } = _ref7;
  return theme.sanity.color.card.enabled.fg;
}, (_ref8) => {
  let {
    theme
  } = _ref8;
  return theme.sanity.color.card.enabled.bg;
}, (_ref9) => {
  let {
    theme
  } = _ref9;
  return theme.sanity.color.card.enabled.bg;
});
var SimpleMdeReact = (0, import_react3.lazy)(() => import("./SimpleMdeReact-U5EEWRSG.js"));
function useSimpleMdeReact() {
  const [mounted, setMounted] = (0, import_react3.useState)(false);
  (0, import_react3.useEffect)(() => {
    requestAnimationFrame(() => setMounted(true));
  }, []);
  return mounted ? SimpleMdeReact : null;
}
var defaultMdeTools = ["heading", "bold", "italic", "|", "quote", "unordered-list", "ordered-list", "|", "link", "image", "code", "|", "preview", "side-by-side"];
function MarkdownInput(props) {
  var _a2;
  const {
    value = "",
    onChange,
    elementProps: {
      onBlur,
      onFocus,
      ref
    },
    reactMdeProps: {
      options: mdeCustomOptions,
      ...reactMdeProps
    } = {},
    schemaType
  } = props;
  const client = useClient({
    apiVersion: "2022-01-01"
  });
  const {
    imageUrl
  } = (_a2 = schemaType.options) != null ? _a2 : {};
  const imageUpload = (0, import_react3.useCallback)((file, onSuccess, onError) => {
    client.assets.upload("image", file).then((doc) => onSuccess(imageUrl ? imageUrl(doc) : "".concat(doc.url, "?w=450"))).catch((e) => {
      console.error(e);
      onError(e.message);
    });
  }, [client, imageUrl]);
  const mdeOptions = (0, import_react3.useMemo)(() => {
    return {
      autofocus: false,
      spellChecker: false,
      sideBySideFullscreen: false,
      uploadImage: true,
      imageUploadFunction: imageUpload,
      toolbar: defaultMdeTools,
      status: false,
      ...mdeCustomOptions
    };
  }, [imageUpload, mdeCustomOptions]);
  const handleChange = (0, import_react3.useCallback)((newValue) => {
    onChange(PatchEvent.from(newValue ? set$2(newValue) : unset()));
  }, [onChange]);
  const SimpleMdeReact2 = useSimpleMdeReact();
  return (0, import_jsx_runtime2.jsx)(MarkdownInputStyles, {
    children: SimpleMdeReact2 && (0, import_jsx_runtime2.jsx)(import_react3.Suspense, {
      fallback: (0, import_jsx_runtime2.jsx)(Box, {
        padding: 3,
        children: (0, import_jsx_runtime2.jsx)(Text, {
          children: "Loading editor..."
        })
      }),
      children: (0, import_jsx_runtime2.jsx)(SimpleMdeReact2, {
        ...reactMdeProps,
        ref,
        value,
        onChange: handleChange,
        onBlur,
        onFocus,
        options: mdeOptions,
        spellCheck: false
      })
    })
  });
}
var markdownTypeName = "markdown";
var markdownSchemaType = defineType({
  type: "string",
  name: markdownTypeName,
  title: "Markdown",
  components: {
    input: MarkdownInput
  }
});
var markdownSchema = definePlugin((config) => {
  return {
    name: "markdown-editor",
    schema: {
      types: [config && config.input ? {
        ...markdownSchemaType,
        components: {
          input: config.input
        }
      } : markdownSchemaType]
    }
  };
});
export {
  MarkdownInput,
  defaultMdeTools,
  markdownSchema,
  markdownSchemaType
};
//# sourceMappingURL=sanity-plugin-markdown.js.map
